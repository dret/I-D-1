<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>The Key HTTP Response Header Field</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
}
cite {
  font-style: normal;
}
dd {
  margin-right: 2em;
}
dl {
  margin-left: 2em;
}

ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
  margin-right: 2em;
}
ol {
  margin-left: 2em;
  margin-right: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
  margin-right: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
  margin-right: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "October 2012"; 
  } 
  @top-center {
       content: "The Key HTTP Response Header Field"; 
  } 
  @bottom-left {
       content: "Fielding & Nottingham"; 
  } 
  @bottom-center {
       content: "Expires April 18, 2013"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The &#8220;Key&#8221; Response Header Field" href="#rfc.section.2"><link rel="Chapter" title="3 IANA Considerations" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" href="#rfc.section.5" title="5 Normative References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.576, 2012-05-02 14:26:45, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Fielding, R."><meta name="dct.creator" content="Nottingham, M."><meta name="dct.identifier" content="urn:ietf:id:draft-fielding-http-key-01"><meta name="dct.issued" scheme="ISO8601" content="2012-10-15"><meta name="dct.abstract" content="The &#8216;Key&#8217; header field for HTTP responses allows an origin server to describe the cache key for a negotiated response: a short algorithm that can be used upon later requests to determine if the same response is reusable.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending Accept* fields in order to reduce the risk of fingerprinting."><meta name="description" content="The &#8216;Key&#8217; header field for HTTP responses allows an origin server to describe the cache key for a negotiated response: a short algorithm that can be used upon later requests to determine if the same response is reusable.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending Accept* fields in order to reduce the risk of fingerprinting."></head><body><table class="header"><tbody><tr><td class="left">Network Working Group</td><td class="right">R. Fielding</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Adobe Systems Incorporated</td></tr><tr><td class="left">Intended status: Informational</td><td class="right">M. Nottingham</td></tr><tr><td class="left">Expires: April 18, 2013</td><td class="right">October 15, 2012</td></tr></tbody></table><p class="title">The Key HTTP Response Header Field<br><span class="filename">draft-fielding-http-key-01</span></p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>The &#8216;Key&#8217; header field for HTTP responses allows an origin server to describe the cache key for a negotiated response: a short algorithm that can be used upon later requests to determine if the same response is reusable.</p><p>Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.</p><p>Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending Accept* fields in order to reduce the risk of fingerprinting.</p><h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#8220;work in progress&#8221;.</p><p>This Internet-Draft will expire on April 18, 2013.</p><h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1><p>Copyright © 2012 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="introduction" href="#introduction">Introduction</a></h1><p id="rfc.section.1.p.1">In HTTP caching <a href="#I-D.ietf-httpbis-p6-cache"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[I-D.ietf-httpbis-p6-cache]</cite></a>, the Vary response header field effectively modifies the key used to store and access a response to include information from the request&#8217;s headers. This allows proactive content negotiation <a href="#I-D.ietf-httpbis-p2-semantics"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[I-D.ietf-httpbis-p2-semantics]</cite></a> to work with caches.</p><p id="rfc.section.1.p.2">However, Vary&#8217;s operation is coarse-grained; although caches are allowed to normalise the values of headers based upon their semantics, doing so requires the cache to understand those semantics, and is still quite limited.</p><p id="rfc.section.1.p.3">For example, if a response is cached with the response header field:</p><div id="rfc.figure.u.1"></div><pre>
  Vary: Accept-Encoding
</pre><p id="rfc.section.1.p.5">and and its associated request is:</p><div id="rfc.figure.u.2"></div><pre>
  Accept-Encoding: gzip
</pre><p id="rfc.section.1.p.7">then a subsequent request with the following header is (in a strict reading of HTTP) not a match, resulting in a cache miss:</p><div id="rfc.figure.u.3"></div><pre>
  Accept-Encoding: identity, gzip
</pre><p id="rfc.section.1.p.9">This document defines a new response header field, &#8220;Key&#8221;, that allows servers to describe the cache key in a much more fine-grained manner, leading to improved cache efficiency.</p><h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="notational-conventions" href="#notational-conventions">Notational Conventions</a></h2><p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><p id="rfc.section.1.1.p.2">This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> with the list rule extension defined in <a href="#I-D.ietf-httpbis-p1-messaging"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[I-D.ietf-httpbis-p1-messaging]</cite></a>, Appendix B. It includes by reference the OWS, field-name and quoted-string rules from that document, and the parameter rule from <a href="#I-D.ietf-httpbis-p2-semantics"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[I-D.ietf-httpbis-p2-semantics]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="the-key-response-header-field" href="#the-key-response-header-field">The &#8220;Key&#8221; Response Header Field</a></h1><p id="rfc.section.2.p.1">The &#8220;Key&#8221; response header field describes the request attributes that the server has used to select the current representation.</p><p id="rfc.section.2.p.2">As such, its semantics are similar to the &#8220;Vary&#8221; response header field, but it allows more fine-grained description, using &#8220;key modifiers&#8221;.</p><p id="rfc.section.2.p.3">Caches can use this information as part of determining whether a stored response can be used to satisfy a given request. When a cache fully implements this mechanism, it MAY ignore the Vary response header field.</p><p id="rfc.section.2.p.4">Additionally, user agents can use this information to discover if additional request header fields might influence the resulting response.</p><p id="rfc.section.2.p.5">The Key field-value is a comma-delimited list of selecting header fields (similar to Vary), with zero to many modifiers to each, delimited by semicolons. Whitespace is not allowed in the field-value between each field-name and its parameter set.</p><div id="rfc.figure.u.4"></div><pre>
  Key = 1#field-name *( ";" parameter )
</pre><p id="rfc.section.2.p.7">The following header fields therefore have identical semantics:</p><div id="rfc.figure.u.5"></div><pre>
  Vary: Accept-Encoding, Accept-Language
  Key: Accept-Encoding, Accept-Language
</pre><p id="rfc.section.2.p.9">However, Key&#8217;s use of modifiers allows:</p><div id="rfc.figure.u.6"></div><pre>
  Key: Accept-Encoding;w="gzip", Accept-Language;b="fr"
</pre><p id="rfc.section.2.p.11">to indicate that the response it occurs in is allowed to be reused for requests that contain the token &#8220;gzip&#8221; (in any case) in the Accept-Encoding header field and an Accept-Language header field value that starts with &#8220;fr&#8221; (in any case).</p><p id="rfc.section.2.p.12">Note that both the field-name and modifier names themselves are case insensitive.</p><h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="header-matching" href="#header-matching">Header Matching</a></h2><p id="rfc.section.2.1.p.1">When used by a cache to determine whether a stored response can be used to satisfy a presented request, each field-name identifies a potential request header, just as with the Vary response header field.</p><p id="rfc.section.2.1.p.2">However, each of these can have zero to many &#8220;key modifiers&#8221; that change how the response selection process (as defined in <a href="#I-D.ietf-httpbis-p6-cache"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[I-D.ietf-httpbis-p6-cache]</cite></a>, Section 4.3)) works.</p><p id="rfc.section.2.1.p.3">In particular, a cache that implements the Key header field MUST NOT use a stored response unless all of the selecting header fields nominated by the Key header field match in both the original request (i.e., that associated with the stored response) and the presented request.</p><p id="rfc.section.2.1.p.4">Modifiers operate on a list of zero to many field-values. This list is constructed by:</p><p id="rfc.section.2.1.p.5"> </p><ol><li>Starting with the field-values of all header fields that have the given field-name.</li><li>Splitting each field-value on commas, excluding any that occur inside of a quoted-string production.</li><li>Flattening the list of lists into a single list that represents the individual header field-values.</li><li>Case-normalising each value in both lists to lowercase.</li><li>Trimming any OWS from the start and end of the field-values.</li></ol><p id="rfc.section.2.1.p.6">For example, given the set of headers:</p><div id="rfc.figure.u.7"></div><pre>
 Foo: 1
 Bar: z
 Foo: 2, a="b,c"
</pre><p id="rfc.section.2.1.p.8">A modifier for &#8220;Foo&#8221; would operate on the list of presented values &#8216;1&#8217;, &#8216;2&#8217;, &#8216;a=&#8221;b,c&#8221;&#8217;.</p><p id="rfc.section.2.1.p.9">Note that step 2 of this algorithm optimistically assumes that double-quotes in a header field value denote the use of the quoted-string as defined by <a href="#I-D.ietf-httpbis-p1-messaging"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[I-D.ietf-httpbis-p1-messaging]</cite></a>; the cache does not need to &#8220;understand&#8221; the specific header field.</p><p id="rfc.section.2.1.p.10">Once the appropriate header fields from both the original request and the stored request are processed in this manner, the result is two (possibly empty) lists of values for each specified header field.</p><p id="rfc.section.2.1.p.11">The key modifiers (as specified in the Key header field) are then applied to the lists in the order they appear in Key (left to right). If any modifier does not return a match (as per its definition), the headers are said not to match. If all of the modifiers return a match, the headers are said to match.</p><p id="rfc.section.2.1.p.12">Note that some types of modifiers are said to always match; they can be used to alter the input lists, or to alter the semantics of subsequent matches.</p><p id="rfc.section.2.1.p.13">Unrecognised modifiers MUST result in a failure to match.</p><h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="key-modifiers" href="#key-modifiers">Key Modifiers</a></h2><p id="rfc.section.2.2.p.1">This document defines the following key modifiers:</p><h3 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;<a id="w-word-match-modifier" href="#w-word-match-modifier">&#8220;w&#8221;: Word Match Modifier</a></h3><p id="rfc.section.2.2.1.p.1">The &#8220;w&#8221; modifier matches if the parameter value (after unquoting) matches (character-for-character) any whole value in both lists.</p><h3 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2</a>&nbsp;<a id="s-substring-match-modifier" href="#s-substring-match-modifier">&#8221;s&#8221;: Substring Match Modifier</a></h3><p id="rfc.section.2.2.2.p.1">The &#8220;s&#8221; modifier matches if the parameter value (after unquoting) is contained as a sequence of characters within both lists.</p><h3 id="rfc.section.2.2.3"><a href="#rfc.section.2.2.3">2.2.3</a>&nbsp;<a id="b-beginning-substring-match-modifier" href="#b-beginning-substring-match-modifier">&#8220;b&#8221;: Beginning Substring Match Modifier</a></h3><p id="rfc.section.2.2.3.p.1">The &#8220;b&#8221; modifier matches if both lists contain a value that begins with the same sequence of characters as the parameter value (after unquoting).</p><h3 id="rfc.section.2.2.4"><a href="#rfc.section.2.2.4">2.2.4</a>&nbsp;<a id="p-parameter-prefix-match-modifier" href="#p-parameter-prefix-match-modifier">&#8220;p&#8221;: Parameter Prefix Match Modifier</a></h3><p id="rfc.section.2.2.4.p.1">The &#8220;p&#8221; modifier matches if the parameter value (after unquoting) matches (character-for-character) the sequence of characters up to (but not including) the first semi-colon (&#8220;;&#8221;) in both lists, after any whitespace is removed.</p><p id="rfc.section.2.2.4.p.2">For example, given the key:</p><div id="rfc.figure.u.8"></div><pre>
 Key: Accept;p="text/html"
</pre><p id="rfc.section.2.2.4.p.4">then each of the following header fields is a match:</p><div id="rfc.figure.u.9"></div><pre>
 Accept: text/html
 Accept: text/html; q=0.5
 Accept: text/html;q=0.1
 Accept: text/html; foo="bar"
</pre><h3 id="rfc.section.2.2.5"><a href="#rfc.section.2.2.5">2.2.5</a>&nbsp;<a id="c-case-sensitivity-flag" href="#c-case-sensitivity-flag">&#8220;c&#8221;: Case Sensitivity Flag</a></h3><p id="rfc.section.2.2.5.p.1">The &#8220;c&#8221; modifier always matches, and has the side effect of reverting the case normalisation of the header lists (see #4 in the list above), so that subsequent matches become case sensitive.</p><h3 id="rfc.section.2.2.6"><a href="#rfc.section.2.2.6">2.2.6</a>&nbsp;<a id="n-not-flag" href="#n-not-flag">&#8220;n&#8221;: Not Flag</a></h3><p id="rfc.section.2.2.6.p.1">The &#8220;n&#8221; modifier always matches, and has the side effect of modifying the semantics of subsequent modifiers (i.e., the match modifiers to its right, lexically) so that they will be considered to match if they do not, and likewise they will be considered not to match if they do.</p><p id="rfc.section.2.2.6.p.2">For example, given a response with:</p><div id="rfc.figure.u.10"></div><pre>
  Key: Foo;w="a";n;w="b"
</pre><p id="rfc.section.2.2.6.p.4">then the presented header:</p><div id="rfc.figure.u.11"></div><pre>
  Foo: a, c
</pre><p id="rfc.section.2.2.6.p.6">would match, while</p><div id="rfc.figure.u.12"></div><pre>
  Foo: a, b
</pre><p id="rfc.section.2.2.6.p.8">would not (because it contains &#8220;b&#8221;).</p><h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="examples" href="#examples">Examples</a></h2><p id="rfc.section.2.3.p.1">For example, this response header field:</p><div id="rfc.figure.u.13"></div><pre>
  Key: cookie;w="_sess=fhd378";c;w="ID=\"Roy\"", 
       Accept-Encoding;w="gzip"
</pre><p id="rfc.section.2.3.p.3">would allow the cache to reuse the response it occurs in if the presented request contains:</p><p id="rfc.section.2.3.p.4"> </p><ul><li>A Cookie header containing both ID=&#8221;Roy&#8221; (in that case) and _sess=fhd378 (evaluated case insensitively), and</li><li>An Accept-Encoding header containing the token &#8220;gzip&#8221; (evaluated case insensitively).</li></ul><p id="rfc.section.2.3.p.5">Less convoluted examples include matching any request with a User-Agent field value containing &#8220;MSIE&#8221; in any combination of case:</p><div id="rfc.figure.u.14"></div><pre>
  Key: user-agent;s="MSIE"
</pre><p id="rfc.section.2.3.p.7">And an Accept-Language field value for French:</p><div id="rfc.figure.u.15"></div><pre>
  Key: accept-language;b="fr"
</pre><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="iana-considerations" href="#iana-considerations">IANA Considerations</a></h1><p id="rfc.section.3.p.1">TBD</p><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="security-considerations" href="#security-considerations">Security Considerations</a></h1><p id="rfc.section.4.p.1">TBD</p><h1 class="np" id="rfc.references"><a href="#rfc.section.5" id="rfc.section.5">5.</a> Normative References</h1><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC5234">[RFC5234]</b></td><td class="top">Crocker, D. and P. Overell, &#8220;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>&#8221;, STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008.</td></tr><tr><td class="reference"><b id="I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</b></td><td class="top">Fielding, R. and J. Reschke, &#8220;<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>&#8221;, Internet-Draft&nbsp;draft-ietf-httpbis-p1-messaging-21 (work in progress), October&nbsp;2012.</td></tr><tr><td class="reference"><b id="I-D.ietf-httpbis-p2-semantics">[I-D.ietf-httpbis-p2-semantics]</b></td><td class="top">Fielding, R. and J. Reschke, &#8220;<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-21">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>&#8221;, Internet-Draft&nbsp;draft-ietf-httpbis-p2-semantics-21 (work in progress), October&nbsp;2012.</td></tr><tr><td class="reference"><b id="I-D.ietf-httpbis-p6-cache">[I-D.ietf-httpbis-p6-cache]</b></td><td class="top">Fielding, R., Nottingham, M., and J. Reschke, &#8220;<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-21">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>&#8221;, Internet-Draft&nbsp;draft-ietf-httpbis-p6-cache-21 (work in progress), October&nbsp;2012.</td></tr></table><hr class="noprint"><div class="avoidbreak"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Authors' Addresses</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Roy T. Fielding</span><span class="n hidden"><span class="family-name">Fielding</span><span class="given-name">Roy T.</span></span></span><span class="org vcardline">Adobe Systems Incorporated</span><span class="vcardline">EMail: <a href="mailto:fielding@gbiv.com"><span class="email">fielding@gbiv.com</span></a></span><span class="vcardline">URI: <a href="http://roy.gbiv.com/" class="url">http://roy.gbiv.com/</a></span></address><address class="vcard"><span class="vcardline"><span class="fn">Mark Nottingham</span><span class="n hidden"><span class="family-name">Nottingham</span><span class="given-name">Mark</span></span></span><span class="vcardline">EMail: <a href="mailto:mnot@mnot.net"><span class="email">mnot@mnot.net</span></a></span><span class="vcardline">URI: <a href="http://www.mnot.net/" class="url">http://www.mnot.net/</a></span></address></div></body></html>