<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-02" category="std" updates="7234">

  <front>
    <title>HTTP Representation Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2018"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces an alternative way to communicate a secondary cache key for a HTTP resource, using the HTTP “Variants” and “Variant-Key” response header fields. Its aim is to make HTTP proactive content negotiation more cache-friendly.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</eref>.</t>

<t>There is a prototype implementation of the algorithms herein at <eref target="https://github.com/mnot/variants-toy">https://github.com/mnot/variants-toy</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is seeing renewed interest, both for existing request headers like Content-Language and for newer ones (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1). Currently, the Vary header (<xref target="RFC7231"/>, Section 7.1.4) does this by nominating a set of request headers.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising those request header field values, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, normalisation is not formally defined, leading to divergence in cache behaviours.</t>

<t>Even when the headers’ semantics are understood, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP Variants response header field (<xref target="variants"/>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following the algorithm defined in <xref target="cache"/>.</t>

<t>Its companion the Variant-Key response header field (<xref target="variant-key"/>) indicates which representation was selected, so that it can be reliably reused in the future. When this specification is in use, the example above might become:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Variants: Accept-Language;fr;de;en;jp
Variant-Key: fr
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Proactive content negotiation mechanisms that wish to be used with Variants need to define how to do so explicitly; see <xref target="define"/>. As a result, it is best suited for negotiation over request headers that are well-understood.</t>

<t>Variants also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</t>

<t>Variants can be seen as a simpler version of the Alternates header field introduced by <xref target="RFC2295"/>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="variants" title="The “Variants” HTTP Header Field">

<t>The Variants HTTP response header field indicates what representations are available for a given resource at the time that the response is produced, by enumerating the request header fields that it varies on, along with the values that are available for each.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <xref target="content-encoding"/>).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: accept-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always, field-name is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response (in this example, the first language is the default; see <xref target="content-language"/>).</t>

<t>The ordering of the request header fields themselves indicates descending application of preferences; in the example above, a cache that has all of the possible permutations stored will honour the client’s preferences for Accept-Encoding before honouring Accept-Language.</t>

<t>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</t>

<t>Likewise, servers MUST send the Variant-Key response header field when sending Variants, since its absence means that the stored response will not be reused when this specification is implemented.</t>

<section anchor="vary" title="Relationship to Vary">

<t>Caches that implement this specification SHOULD ignore request header fields in the Vary header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are implemented as per this specification and their corresponding response header field is listed in Variants.</t>

<t>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</t>

<t>See <xref target="partial"/> for an example.</t>

<t>In practice, implementation of Vary varies considerably. As a result, cache efficiency might drop considerably when Variants does not contain all of the headers referenced by Vary, because some implementations might choose to disable Variants processing when this is the case.</t>

</section>
</section>
<section anchor="variant-key" title="The “Variant-Key” HTTP Header Field">

<t>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</t>

<figure><artwork><![CDATA[
Variant-Key     = 1#available-value
]]></artwork></figure>

<t>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</t>

<t>Therefore, Variant-Key MUST be the same length (in comma-separated members) as Variants, and each member MUST correspond in position to its companion in Variants.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
]]></artwork></figure>

<t>This header pair indicates that the representation has a “gzip” content-coding and “fr” content-language.</t>

<t>Note that Variant-Key is only used to indicate what request attributes are associated with the response containing it; this is different from headers like Content-Encoding, which indicate attributes of the response itself. In the example above, it might be that a gzip’d version of the French content is not available, in which case the response will include:</t>

<figure><artwork><![CDATA[
Variant-Key: gzip, fr
]]></artwork></figure>

<t>even though Content-Encoding does not contain “gzip”.</t>

<section anchor="gen-variant-key" title="Generating a Normalised Variant-Key">

<t>This algorithm generates a normalised string for Variant-Key, suitable for comparison with values generated by <xref target="cache"/>.</t>

<t>Given stored-headers, a set of headers from a stored response, a normalised variant-key for that message can be generated by:</t>

<t><list style="numbers">
  <t>Let variant-key-header be a string, the result of selecting all field-values of stored-headers whose field-name is “Variant-Key” and joining them with a comma (“,”).</t>
  <t>Remove all whitespace from variant-key-header.</t>
  <t>Return variant-key-header.</t>
</list></t>

</section>
</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request:</t>

<t>Given incoming-request, a mapping of field-names to lists of field values, and stored-responses, a list of stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key:</t>

<t><list style="numbers">
  <t>If stored-responses is empty, return an empty list.</t>
  <t>Order stored-responses by the “Date” header field, most recent to least recent.</t>
  <t>Let sorted-variants be an empty list.</t>
  <t>If the freshest member of stored-responses (as per <xref target="RFC7234"/>, Section 4.2) has one or more “Variants” header field(s):
  <list style="numbers">
      <t>Select one member of stored-responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>For each variant in variants-header:
      <list style="numbers">
          <t>If variant’s field-name corresponds to the request header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let request-value be the field-value(s) associated with field-name in incoming-request.</t>
              <t>Let available-values be a list containing all available-value for variant.</t>
              <t>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</t>
              <t>Append sorted-values to sorted-variants.</t>
            </list></t>
        </list>
At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</t>
    </list></t>
  <t>Return result of running Find Available Keys (<xref target="find"/>) on sorted-variants, an empty string and an empty list.</t>
</list></t>

<t>This returns a list of strings suitable for comparing to normalised Variant-Keys (<xref target="gen-variant-key"/>) that represent possible responses on the server that can be used to satisfy the request, in preference order, provided that their secondary cache key (after removing the headers covered by Variants) matches. <xref target="check_vary"/> illustrates one way to do this.</t>

<section anchor="find" title="Find Available Keys">

<t>Given sorted-variants, a list of lists, and key-stub, a string representing a partial key, and possible-keys, a list:</t>

<t><list style="numbers">
  <t>Let sorted-values be the first member of sorted-variants.</t>
  <t>For each sorted-value in sorted-values:
  <list style="numbers">
      <t>If key-stub is an empty string, let this-key be a copy of sorted-value.</t>
      <t>Otherwise:
      <list style="numbers">
          <t>Let this-key be a copy of key-stub.</t>
          <t>Append a comma (“,”) to this-key.</t>
          <t>Append sorted-value to this-key.</t>
        </list></t>
      <t>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</t>
      <t>If remaining-variants is empty, append this-key to possible-keys.</t>
      <t>Otherwise, run Find Available Keys on remaining-variants, this-key and possible-keys.</t>
    </list></t>
  <t>Return possible-keys.</t>
</list></t>

</section>
<section anchor="check_vary" title="Check Vary">

<t>This algorithm is an example of how an implementation can meet the requirement to apply the members of the Vary header field that are not covered by Variants.</t>

<t>Given a stored response, stored-response:</t>

<t><list style="numbers">
  <t>Let filtered-vary be the field-value(s) of stored-response’s “Vary” header field.</t>
  <t>Let processed-variants be a list containing the request header fields that identify the content negotiation mechanisms supported by the implementation.</t>
  <t>Remove any member of filtered-vary that is a case-insensitive match for a member of processed-variants.</t>
  <t>If the secondary cache key (as calculated in <xref target="RFC7234"/>, Section 4.1) for stored_response matches incoming-request, using filtered-vary for the value of the “Vary” response header, return True.</t>
  <t>Return False.</t>
</list></t>

<t>This returns a Boolean that indicates whether stored-response can be used to satisfy the request.</t>

<t>Note that implementation of the Vary header field varies in practice, and the algorithm above illustrates only one way to apply it. It is equally viable to forward the request if there is a request header listed in Vary but not Variants.</t>

</section>
<section anchor="example-of-cache-behaviour" title="Example of Cache Behaviour">

<t>For example, if the selected variants-header was:</t>

<figure><artwork><![CDATA[
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
]]></artwork></figure>

<t>and the request contained the headers:</t>

<figure><artwork><![CDATA[
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
]]></artwork></figure>

<t>Then the sorted-variants would be:</t>

<figure><artwork><![CDATA[
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
]]></artwork></figure>

<t>Which means that the sorted-keys would be:</t>

<figure><artwork><![CDATA[
[
  'fr gzip',
  'fr identity',
  'en gzip',
  'en identity'
]
]]></artwork></figure>

<t>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</t>

<figure><artwork><![CDATA[
Variant-Key: fr, gzip
]]></artwork></figure>

<t>it could be used to satisfy the first preference. If not, responses corresponding to the other keys could be returned, or the request could be forwarded towards the origin.</t>

</section>
</section>
<section anchor="origin" title="Origin Server Behaviour">

<t>Origin servers that wish to take advantage of Variants will need to generate both the Variants (<xref target="variants"/>) and Variant-Key (<xref target="variant-key"/>) header fields in all cacheable responses for a given resource. If either is omitted and the response is stored, it will have the effect of disabling caching for that resource until it is no longer stored (e.g., it expires, or is evicted).</t>

<t>Likewise, origin servers will need to assure that the members of both header field values are in the same order and have the same length, since discrepancies will cause caches to avoid using the responses they occur in.</t>

<t>The value of the Variants header should be relatively stable for a given resource over time; when it changes, it can have the effect of invalidating previously stored responses.</t>

<t>As per <xref target="vary"/>, the Vary header is required to be set appropriately when Variants is in use, so that caches that do not implement this specification still operate correctly.</t>

<t>Origin servers are advised to carefully consider which content negotiation mechanisms to enumerate in Variants; if a mechanism is not supported by a receiving cache, it will “downgrade” to Vary handling, which can negatively impact cache efficiency.</t>

<section anchor="examples" title="Examples">

<t>The operation of Variants is illustrated by the examples below.</t>

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /clancy HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a Content-Language of “en”, and another whose Content-Language is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</t>

<t>So, if a request with “en” in Accept-Language is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the Variants list.</t>

<t>Note that Accept-Language is listed in Vary, to assure backwards-compatibility with caches that do not support Variants.</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /murray HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; Content-Language and Content-Encoding. Thus, there are a total of nine possible representations for the resource (including the identity encoding), and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the Vary’d axes is listed in Variants:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only Accept-Language to be in its field-value – and then continue processing Variants for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
</section>
<section anchor="define" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers two values in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
  <t>Header field name: Variant-Key</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the Variants header by its nature will leak them.</t>

<t>Note that the Variants header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like Variants.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='January' day='26' year='2018' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines an extensible and configurable set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-05.txt' />
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>




    </references>


<section anchor="backports" title="Variants for Existing Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the Variants header field.</t>

<section anchor="content-type" title="Accept">

<t>This section defines handling for Accept variants, as per <xref target="RFC7231"/> Section 5.3.2.</t>

<t>To perform content negotiation for Accept given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-types be a list of the types in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.2 (omitting any coding with a weight of 0). If “Accept” is not present or empty, preferred-types will be empty. If a type lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If the first member of available-values is not a member of preferred-types, append it to preferred-types (thus making it the default).</t>
  <t>For each preferred-type in preferred-types:
  <list style="numbers">
      <t>If any member of available-values matches preferred-type, using the media-range matching mechanism specified in <xref target="RFC7231"/> Section 5.3.2 (which is case-insensitive), append those members of available-values to preferred-available (preserving the precedence order implied by the media ranges’ specificity).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that this algorithm explicitly ignores extension parameters on media types (e.g., “charset”).</t>

</section>
<section anchor="content-encoding" title="Accept-Encoding">

<t>This section defines handling for Accept-Encoding variants, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Accept-Encoding given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty. If a coding lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If “identity” is not a member of preferred-codings, append “identity”.</t>
  <t>Append “identity” to available-values.</t>
  <t>For each preferred-coding in preferred-codings:
  <list style="numbers">
      <t>If there is a case-insensitive, character-for-character match for preferred-coding in available-values, append that member of available-values to preferred-available.</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that the unencoded variant needs to have a Variant-Key header field with a value of “identity”.</t>

</section>
<section anchor="content-language" title="Accept-Language">

<t>This section defines handling for Accept-Language variants, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Accept-Language given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any language-range with a weight of 0). If a language-range lacks a weight, an implementation MAY assign one.</t>
  <t>If the first member of available-values is not a member of preferred-langs, append it to preferred-langs (thus making it the default).</t>
  <t>For each preferred-lang in preferred-langs:
  <list style="numbers">
      <t>If any member of available-values matches preferred-lang, using either the Basic or Extended Filtering scheme defined in <xref target="RFC4647"/> Section 3.3, append those members of available-values to preferred-available (preserving their order).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

</section>
</section>


  </back>

<!-- ##markdown-source:
H4sIAGFPgloAA91caXPbRpr+zl/RS32wlAIpy0cyI21mV77GnvGRtZ2kplKp
FEg0yY5BgEEDkhmV57fve/UFQJIzszOzu/ngiCTQx3s+79E9m80mrWlLfaqe
v3//jXqrd422umrz1tSV+i5vTF61dpIvFo2+OJ0U9bLKt/B00eSrdlbVbWuq
9Sbfzi7k0dnde5Mib+GRe3dPfjdZwp/rutmfKtsWk26HP9lT9dW9+w8mE7Nr
TlXbdLa9d/fu7+HFvNH5qfqjrnSTl5PLuvmwbupudzr5oPfwqThVL6pWN5Vu
Z09wAZOJbfOq+Ckv6wpm3Gs72ZlT9UNbLzMF/5iqgL1kytZN2+iVhb/2W/mj
bcwSflrW210uf2zhYfjJVKWp9I+TSd61m7o5najZRMF/poKVv5qr137X9DUT
5FXefOj/UjfrvDK/Ei1P1bPctuWeftDb3JSnagv0+0/8Zw47oh+6Bpa/adud
PT0+vry8nLtfjyeTqm62MNSFhgWpt88e3zs5+f0pELFahR8mk9lspvIF7A42
NZm83xir7E4vzcosmaemapu66JbaqrxSeYn0pLfVZb4HohEhugof1ypXVi/r
qsibvVrmy41WwAkFE8IvJDAgLXXXLHWmOgs7Vy08Qj9MnexMYZrCf5z9We+n
+NaurqxWG50XulEro8vCztWLFhZltgoWDQvZ5h9ksF1Tw3ZwjbCYFrikKpCq
1vCOtnWjeXWzVWN0VZT7ORMCiKd/eo3/tPVPb2kuO5l8AcRTT5+8eP/m7ana
lTqHhTR6W8PwLdFLL2nchV7hyLtuUQrxvkCKalie7YB8pbEt0YLeIo2AZeB7
8G0Hm85b9e+OmWvTbrrFHIh7jDw9fjF7clzmC13aY6c6f5jz8Nsaxm30Evd5
WK9gv0DdipZhN7o4kqlgzngCkhSZxdQ0vhv4GEd+ywMuN3m1Rt7DznAD+vZl
okAYGGW9me1yeDdZ8DsNUlLamjhPC7tj1bJrGpwMtLPtLIgc/fri6ftnCgxA
jsL5QTcZzDzxM0c/zI1uV3PQnmOwN8fXmppjIVijiRYoJW3d7nfwcQts3Xoz
Vq9o/rwESwT721qFL8Gqbtq5N2htvf+DyNPWFEWpJ5MDtEOkRTj+ZPIZQnp4
dfVvIHdg+E4+fcrUO5Gx+/MH85MjRVKnUYGAbvoSmGLQ0GkLhmlRtxsSM/0R
+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
DZk7zVlLZAAA

-->

</rfc>

