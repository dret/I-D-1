<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-00" category="std" updates="7234">

  <front>
    <title>HTTP Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces the HTTP <spanx style="verb">Variants</spanx> response header field to communicate what representations are available for a given resource.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variant">https://github.com/mnot/I-D/labels/variant</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variant/">https://mnot.github.io/I-D/variant/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variant">https://github.com/mnot/I-D/commits/gh-pages/variant</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variant/">https://datatracker.ietf.org/doc/draft-nottingham-variant/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is starting to be used more widely again. The most widely seen use – determining a response’s content-coding – is being joined by renewed interest in negotiation for language and other, newer attributes (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1) using the Vary header (<xref target="RFC7231"/>, Section 7.1.4), which identifies the request headers that form the secondary cache key for a given response.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising request header fields to match those stored in the cache, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even with understanding of the headers’ semantics to facilitate such normalisation, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of <spanx style="verb">Accept-Language</spanx> and <spanx style="verb">Content-Language</spanx>, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, thereby incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP <spanx style="verb">Variants</spanx> response header field to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin.</t>

<t><spanx style="verb">Variants</spanx> is best used when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations. Likewise, it works best for content negotiation over header fields whose semantics are well-understood, since it requires a selection algorithm to be specified ahead of time.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="the-variants-http-header-field" title="The “Variants” HTTP Header Field">

<t>The <spanx style="verb">Variant</spanx> HTTP response header field is used to indicate what other representations are available for a given resource at the time that the response is produced.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant
variant         = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each <spanx style="verb">variant</spanx> indicates a response header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see {{content-encoding}).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: content-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings are supported. Note that as always with header field names, it is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;brotli, Content-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two Content-Encodings are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;brotli
Variants: Content-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response.</t>

<t>Senders SHOULD consistently send <spanx style="verb">Variant</spanx> header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to <spanx style="verb">Vary</spanx> processing.</t>

<t>Likewise, servers MUST send the <spanx style="verb">Content-*</spanx> response headers nominated by <spanx style="verb">Variants</spanx> when sending that header.</t>

<section anchor="defining-content-negotiation-using-variants" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define a response header field that indicates the result of selection, whose field-name SHOULD begin with “Content-“ and whose field-value SHOULD be a token.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return an ordered list of selected responses, given the incoming request, a list of selected responses, and the list of available values from <spanx style="verb">Variants</spanx>. If the result is an empty list, it implies that the cache does not contain an appropriate response.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

<t>Note that unlike Vary, Variants does not use stored request headers to help select a response; this is why defining a response header to aid identification and selection is required.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the <spanx style="verb">Variants</spanx> header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request, <spanx style="verb">incoming-request</spanx>:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">selected-responses</spanx> be a list of the stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key.</t>
  <t>Order <spanx style="verb">selected-responses</spanx> by the “Date” header field, most recent to least recent.</t>
  <t>If the freshest (as per <xref target="RFC7234"/>, Section 4.2) has one or more <spanx style="verb">Variants</spanx> header field(s):
  <list style="numbers">
      <t>Select one member of <spanx style="verb">selected-responses</spanx> and let its “Variants” header field-value(s) be <spanx style="verb">Variants</spanx>. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>For each <spanx style="verb">variant</spanx> in <spanx style="verb">Variants</spanx>:
      <list style="numbers">
          <t>If the <spanx style="verb">field-name</spanx> corresponds to the response header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let <spanx style="verb">available-values</spanx> be a list containing all <spanx style="verb">available-value</spanx> for the <spanx style="verb">variant</spanx>.</t>
              <t>Let <spanx style="verb">selected-responses</spanx> be the result of running the algorithm defined by the content negotiation mechanism with <spanx style="verb">incoming-request</spanx>, <spanx style="verb">selected-responses</spanx> and <spanx style="verb">available-values</spanx>.</t>
              <t>For the purposes of selecting a response, ignore the content negotiation’s identified request header field-name in the “Vary” header field of each member of <spanx style="verb">selected-responses</spanx>, if present.</t>
            </list></t>
        </list></t>
    </list></t>
  <t>Process any member of <spanx style="verb">selected-responses</spanx> that has a “Vary” response header field whose field-value still contains one or more <spanx style="verb">field-name</spanx>s, removing that members if it does not match (as per <xref target="RFC7234"/>, Section 4.1).</t>
  <t>Return the first member of <spanx style="verb">selected-responses</spanx>. If <spanx style="verb">selected-responses</spanx> is empty, return <spanx style="verb">null</spanx>.</t>
</list></t>

<t>This algorithm will either return the appropriate stored response to use, or <spanx style="verb">null</spanx> if the cache needs to forward the request towards the origin server.</t>

<section anchor="relationship-to-vary" title="Relationship to Vary">

<t>Caches that fully implement this specification MUST ignore request header-fields in the <spanx style="verb">Vary</spanx> header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are understood, implemented as per this specification, and their corresponding response header field is listed in <spanx style="verb">Variants</spanx>.</t>

<t>Request header fields listed in <spanx style="verb">Vary</spanx> that are not implemented in terms of this specification or not present in the <spanx style="verb">Variants</spanx> field SHOULD still form part of the secondary cache key.</t>

<t>The algorithm in <xref target="cache"/> implements these requirements.</t>

</section>
</section>
<section anchor="examples" title="Examples">

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <spanx style="verb">Content-Language</spanx> of “en”, and another whose <spanx style="verb">Content-Language</spanx> is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm <spanx style="verb">Accept-Language</spanx> and <spanx style="verb">Content-Language</spanx> determines.</t>

<t>So, a request with “en” in <spanx style="verb">Accept-Language</spanx> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <spanx style="verb">Variants</spanx> list.</t>

<t>Note that <spanx style="verb">Accept-Language</spanx> is listed in Vary, to assure backwards-compatibility with caches that do not support <spanx style="verb">Variants</spanx>.</t>

<t>Also, note that is is the response header which is listed in Variants, not the request header (the opposite of Vary).</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; <spanx style="verb">Content-Language</spanx> and <spanx style="verb">Content-Encoding</spanx>. Thus, there are a total of six possible representations for the resource, and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial-coverage" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the varied axes is listed in <spanx style="verb">Variants</spanx>:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only <spanx style="verb">Accept-Language</spanx> to be in its field-value – and then continue processing <spanx style="verb">Variants</spanx> for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers one value in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <spanx style="verb">Variants</spanx> header by its nature will leak them.</t>

<t>Note that the <spanx style="verb">Variants</spanx> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='April' day='18' year='2017' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines a set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-04.txt' />
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>




    </references>


<section anchor="backports" title="Variants and Defined Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the <spanx style="verb">Variants</spanx> header field.</t>

<section anchor="content-encoding" title="Content-Encoding">

<t>When negotiating for the <spanx style="verb">Content-Encoding</spanx> response header field’s value, the applicable request header field is <spanx style="verb">Accept-Encoding</spanx>, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Content-Encoding given an <spanx style="verb">incoming-request</spanx>, <spanx style="verb">stored-responses</spanx> and <spanx style="verb">available-values</spanx>:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">preferred-codings</spanx> be a list of the <spanx style="verb">coding</spanx>s in the “Accept-Encoding” header field of <spanx style="verb">incoming-request</spanx>, ordered by their <spanx style="verb">weight</spanx>, highest to lowest. If “Accept-Encoding” is not present or empty, <spanx style="verb">preferred-codings</spanx> will be empty.</t>
  <t>If <spanx style="verb">identity</spanx> is not a member of <spanx style="verb">preferred-codings</spanx>, append <spanx style="verb">identity</spanx> to <spanx style="verb">preferred-codings</spanx> with a <spanx style="verb">weight</spanx> of 0.001.</t>
  <t>Remove any member of <spanx style="verb">preferred-codings</spanx> whose <spanx style="verb">weight</spanx> is 0.</t>
  <t>Append “identity” to <spanx style="verb">available-values</spanx>.</t>
  <t>Remove any member of <spanx style="verb">available-values</spanx> not present in <spanx style="verb">preferred-codings</spanx>, comparing in a case-insensitive fashion.</t>
  <t>Let <spanx style="verb">filtered-responses</spanx> be an empty list.</t>
  <t>For each <spanx style="verb">available-value</spanx> of <spanx style="verb">available-values</spanx>:
  <list style="numbers">
      <t>If there is a member of <spanx style="verb">stored-responses</spanx> whose “Content-Encoding” field-value has <spanx style="verb">content-coding</spanx>s (<xref target="RFC7231"/>, Section 3.1.2.2) that all match members of <spanx style="verb">available-value</spanx> in a case-insensitive fashion, append that stored response to <spanx style="verb">filtered-responses</spanx>.</t>
    </list></t>
  <t>If there is a member of <spanx style="verb">stored-responses</spanx> that does not have a “Content-Encoding” header field, append that stored response to <spanx style="verb">filtered-responses</spanx>.</t>
  <t>Return <spanx style="verb">filtered-responses</spanx>.</t>
</list></t>

<t>This algorithm selects the stored response(s) in order of preference by the client; if none are stored in cache, the request will be forwarded towards the origin. It defaults to the “identity” non-encoding.</t>

<t>Implementations MAY remove members of <spanx style="verb">filtered-responses</spanx> based upon their <spanx style="verb">weight</spanx> or other criteria before returning. For example, they might wish to return an empty list when the client’s most-preferred available response is not stored, so as to populate the cache as well as honour the client’s preferences.</t>

</section>
<section anchor="content-language" title="Content-Language">

<t>When negotiating for the <spanx style="verb">Content-Language</spanx> response header field’s value, the applicable request header field is <spanx style="verb">Accept-Language</spanx>, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Content-Language given an <spanx style="verb">incoming-request</spanx>, <spanx style="verb">stored-responses</spanx> and <spanx style="verb">available-values</spanx>:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">preferred-langs</spanx> be a list of the <spanx style="verb">language-range</spanx>s in the “Accept-Language” header field (<xref target="RFC7231"/>, Section 5.3.5) of <spanx style="verb">incoming-request</spanx>, ordered by their <spanx style="verb">weight</spanx>, highest to lowest.</t>
  <t>If <spanx style="verb">preferred-langs</spanx> is empty, append “*” with a <spanx style="verb">weight</spanx> of 0.001.</t>
  <t>Remove any member of <spanx style="verb">preferred-langs</spanx> whose <spanx style="verb">weight</spanx> is 0.</t>
  <t>Filter <spanx style="verb">available-values</spanx> using <spanx style="verb">preferred-langs</spanx> with either the Basic Filtering scheme defined in <xref target="RFC4647"/> Section 3.3.1, or the Lookup scheme defined in Section 3.4 of that document. Use the first member of <spanx style="verb">available-values</spanx> as the default.</t>
  <t>Let <spanx style="verb">filtered-responses</spanx> be an empty list.</t>
  <t>For each <spanx style="verb">available-value</spanx> of <spanx style="verb">available-values</spanx>:
  <list style="numbers">
      <t>If there is a member of <spanx style="verb">stored-responses</spanx> whose “Content-Language” field-value has a <spanx style="verb">language-tag</spanx> (<xref target="RFC7231"/>, Section 3.1.3.2) that matches <spanx style="verb">available-value</spanx> in a case-insensitive fashion, append that stored response to <spanx style="verb">filtered-responses</spanx>.</t>
    </list></t>
  <t>Return <spanx style="verb">filtered-responses</spanx>.</t>
</list></t>

<t>This algorithm selects the available response(s) (according to <spanx style="verb">Variants</spanx>) in order of preference by the client; if none are stored in cache, the request will be forwarded towards the origin. If no preferred language can be selected, the first <spanx style="verb">available-value</spanx> will be used as the default.</t>

<t>Implementations MAY remove members of <spanx style="verb">filtered-responses</spanx> based upon their <spanx style="verb">weight</spanx> or other criteria before returning. For example, they might wish to return an empty list when the client’s most-preferred available response is not stored, so as to populate the cache as well as honour the client’s preferences.</t>

</section>
</section>


  </back>

<!-- ##markdown-source:
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
GyXXzUc5ZNtznZ0pxsD+WZiTvh9NOrkdTnIW3XOLYOtXvpp4FB/jXNcdkrZD
GDehGaF8cb3kvIXRiiMDkTGJxtHXXySIboeIXhKUY3LpjsP/EGHf+FHT+PX+
lMgmu2MNQBxba3taCBlrz1r5OSedwjrhcxQ5p1ztW3n2jbxBxdirFAcvm+CJ
JQhdsslqP3O+4lgt5gydAbKhYbl9mTm0ilG/kJhn0pmMLiYitnELGgoDzECl
exeay2jcWXTegQuOee7wtSnfO+x6nh8cWdFBtMOx/8y7fuecdNuHpfYYCTZ4
w9E2T8M2dnDmdVPkmDV29gpOy/Wiuu85tlHdNS8/K6q3RdyfG9WDd91uiur3
vyyqe47/F6M6inA0pjvZziosvIax3RHXi+1XoCJxv/+nRH4XqAc8tGNnC0uT
O5N/Lubaha+KuE/JYcfiJr/kMrISvTbHnXcU5kNpdGLXwScMeMhWDbPie1/d
exDY0l2Q5hHNwHGRF0Vx3pQjzwZvy/tXhF0xHIv3dugwmPUP2ZEMfhbxKIP4
gkj+1V8RyVvz7EdyGdh2LSHJvyaQ3/WBnII4RMd/Tex+8E+EyCE8Y5Tck0lS
2Bcpi6CO+qviJx1rbGOKH0P5Di8fK5kGJjoUvduLTvX3jfT/w+4fDrv/Aybm
vKj6RwAA

-->

</rfc>

