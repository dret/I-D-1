<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-01" category="std" updates="7234">

  <front>
    <title>HTTP Representation Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces the HTTP “Variants” response header field to communicate what representations are available for a given resource, and the companion “Variant-Key” response header field to indicate which representation was selected. It is an augmentation of the “Vary” mechanism in HTTP caching.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is starting to be used more widely again. The most widely seen use – determining a response’s content-coding – is being joined by renewed interest in negotiation for language and other, newer attributes (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1) using the Vary header (<xref target="RFC7231"/>, Section 7.1.4), which identifies the request headers that form the secondary cache key for a given response.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising request header fields identified by Vary to match those stored in the cache, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even with understanding of the headers’ semantics to facilitate such normalisation, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, thereby incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP Variants response header field (<xref target="variants"/>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following an algorithm defined in <xref target="cache"/>.</t>

<t>Its companion the Variant-Key response header field (<xref target="variant-key"/>) indicates which representation was selected, so that it can be reliably reused in the future.</t>

<t>This mechanism requires that proactive content negotiation mechanisms define how they use it; see <xref target="define"/>. It is best suited for negotiation over request headers that are well-understood. It also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</t>

<t>It can be seen as a simpler version of the Alternates header field introduced by <xref target="RFC2295"/>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="variants" title="The “Variants” HTTP Header Field">

<t>The Variants HTTP response header field indicates what representations are available for a given resource at the time that the response is produced, by enumerating the request header fields that it varies on, along with the values that are available for each.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <xref target="content-encoding"/>).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: accept-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always, field-name is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response (see <xref target="content-encoding"/> for an example of this).</t>

<t>The ordering of the request header fields themselves indicates descending application of preferences; for example, in the headers above, a cache will serve gzip’d content regardless of language if it is available.</t>

<t>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</t>

<t>Likewise, servers MUST send the Variant-Key response header field when sending Variants.</t>

<section anchor="vary" title="Relationship to Vary">

<t>Caches that fully implement this specification SHOULD ignore request header fields in the <spanx style="verb">Vary</spanx> header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are implemented as per this specification and their corresponding response header field is listed in <spanx style="verb">Variants</spanx>.</t>

<t>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</t>

</section>
</section>
<section anchor="variant-key" title="The “Variant-Key” HTTP Header Field">

<t>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</t>

<figure><artwork><![CDATA[
Variant-Key     = 1#available-value
]]></artwork></figure>

<t>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</t>

<t>Therefore, Variant-Key MUST be the same length (in comma-separated members) as Variants, and each member MUST correspond in position to its companion in Variants.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
]]></artwork></figure>

<t>This header pair indicates that the representation is used for responses that have a “gzip” content-coding and “fr” content-language.</t>

<t>Note that the contents of Variant-Key are only used to indicate what request attributes are identified with the response containing it; this is different from headers like Content-Encoding, which indicate attributes of the response. In the example above, it might be that a gzip’d version of the French content is not available, in which case it will not include “Content-Encoding: gzip”, but still have “gzip” in Variant-Key.</t>

</section>
<section anchor="define" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request, incoming-request:</t>

<t><list style="numbers">
  <t>Let selected-responses be a list of the stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key.</t>
  <t>Order selected-responses by the “Date” header field, most recent to least recent.</t>
  <t>If the freshest (as per <xref target="RFC7234"/>, Section 4.2) has one or more “Variants” header field(s):
  <list style="numbers">
      <t>Select one member of selected_responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>Let sorted-variants be an empty list.</t>
      <t>For each variant in variants-header:
      <list style="numbers">
          <t>If variant’s field-name corresponds to the response header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let request-value be the field-value of the request header field(s) identified by the content negotiation mechanism.</t>
              <t>Let available-values be a list containing all available-value for the variant.</t>
              <t>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</t>
              <t>Append sorted-values to sorted-variants.</t>
            </list></t>
        </list>
At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</t>
      <t>If any member of sorted-variants is an empty list, stop processing and forward the request towards the origin, since an acceptable response is not stored in the cache.</t>
      <t>Let sorted-keys be the result of running Find Available Keys (<xref target="find"/>) on sorted-variants and two empty lists.</t>
    </list></t>
</list></t>

<t>This will result in a list of lists, where each member of the top-level list indicates, in preference order, a key for an acceptable response to the request.</t>

<t>A Cache MAY satisfy the request with any response whose Variant-Key header corresponds to a member of sorted-keys; when doing so, it SHOULD use the most preferred available response.</t>

<t>See also <xref target="vary"/> regarding handling of Vary.</t>

<section anchor="find" title="Find Available Keys">

<t>Given sorted-variants, a list of lists, and key-stub, a list representing a partial key, and possible-keys, a list:</t>

<t><list style="numbers">
  <t>Let sorted-values be the first member of sorted-variants.</t>
  <t>For each sorted-value in sorted-values:
  <list style="numbers">
      <t>Let this-key be a copy of key-stub.</t>
      <t>Append sorted-value to this-key.</t>
      <t>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</t>
      <t>If remaining-variants is empty, append this-key to possible-keys.</t>
      <t>Else, run Find Available Keys on remaining-variants, this-key and possible-keys.</t>
      <t>Return possible-keys.</t>
    </list></t>
</list></t>

</section>
<section anchor="example-of-cache-behaviour" title="Example of Cache Behaviour">

<t>For example, if the selected variants-header was:</t>

<figure><artwork><![CDATA[
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
]]></artwork></figure>

<t>and the request contained the headers:</t>

<figure><artwork><![CDATA[
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
]]></artwork></figure>

<t>Then the sorted-variants would be:</t>

<figure><artwork><![CDATA[
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
]]></artwork></figure>

<t>Which means that the sorted-keys would be:</t>

<figure><artwork><![CDATA[
[
  ['fr', 'gzip'], 
  ['fr', 'identity'], 
  ['en', 'gzip'], 
  ['en', 'identity']
]
]]></artwork></figure>

<t>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</t>

<figure><artwork><![CDATA[
Variant-Key: fr, gzip
]]></artwork></figure>

<t>it could be used to satisfy the first preference. If not, responses corresponding to the other keys could be returned, or the request could be forwarded towards the origin.</t>

</section>
</section>
<section anchor="examples" title="Example Headers">

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <spanx style="verb">Content-Language</spanx> of “en”, and another whose <spanx style="verb">Content-Language</spanx> is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</t>

<t>So, if a request with “en” in <spanx style="verb">Accept-Language</spanx> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <spanx style="verb">Variants</spanx> list.</t>

<t>Note that <spanx style="verb">Accept-Language</spanx> is listed in Vary, to assure backwards-compatibility with caches that do not support <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; <spanx style="verb">Content-Language</spanx> and <spanx style="verb">Content-Encoding</spanx>. Thus, there are a total of six possible representations for the resource, and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial-coverage" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the Vary’d axes is listed in <spanx style="verb">Variants</spanx>:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only <spanx style="verb">Accept-Language</spanx> to be in its field-value – and then continue processing <spanx style="verb">Variants</spanx> for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers two values in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
  <t>Header field name: Variant-Key</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <spanx style="verb">Variants</spanx> header by its nature will leak them.</t>

<t>Note that the <spanx style="verb">Variants</spanx> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='April' day='18' year='2017' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines a set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-04.txt' />
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>




    </references>


<section anchor="backports" title="Variants for Existing Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the <spanx style="verb">Variants</spanx> header field.</t>

<section anchor="content-encoding" title="Accept-Encoding">

<t>This section defines handling for <spanx style="verb">Accept-Encoding</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Accept-Encoding given an request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty.</t>
  <t>If “identity” is not a member of preferred-codings, append “identity”.</t>
  <t>Append “identity” to available-values.</t>
  <t>Remove any member of available-values not present in preferred-codings, comparing in a case-insensitive fashion.</t>
  <t>Return available-values.</t>
</list></t>

</section>
<section anchor="content-language" title="Accept-Language">

<t>This section defines handling for <spanx style="verb">Accept-Language</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Accept-Language given an request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any language-range with a weight of 0).</t>
  <t>If preferred-langs is empty, append “*”.</t>
  <t>Filter available-values using preferred-langs with either the Basic Filtering scheme defined in <xref target="RFC4647"/> Section 3.3.1, or the Lookup scheme defined in Section 3.4 of that document. Use the first member of available-values as the default.</t>
  <t>Return available-values.</t>
</list></t>

</section>
</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

