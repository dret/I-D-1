<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>HTTP Representation Variants</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="../Tools/bower_components/bootstrap/dist/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul ul {
        list-style: none;
      }
      #sidebar {
        position: fixed;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The “Variants” HTTP Header Field" href="#rfc.section.2"><link rel="Chapter" title="3 The “Variant-Key” HTTP Header Field" href="#rfc.section.3"><link rel="Chapter" title="4 Defining Content Negotiation Using Variants" href="#rfc.section.4"><link rel="Chapter" title="5 Cache Behaviour" href="#rfc.section.5"><link rel="Chapter" title="6 Example Headers" href="#rfc.section.6"><link rel="Chapter" title="7 IANA Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 Security Considerations" href="#rfc.section.8"><link rel="Chapter" title="9 Acknowledgments" href="#rfc.section.9"><link rel="Chapter" href="#rfc.section.10" title="10 References"><link rel="Appendix" title="A Variants for Existing Content Negotiation Mechanisms" href="#rfc.section.A"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-variants-01"><meta name="dcterms.issued" content="2017-10-30"><meta name="dcterms.abstract" content="This specification introduces the HTTP “Variants” response header field to communicate what representations are available for a given resource, and the companion “Variant-Key” response header field to indicate which representation was selected. It is an augmentation of the “Vary” mechanism in HTTP caching."><meta name="description" content="This specification introduces the HTTP “Variants” response header field to communicate what representations are available for a given resource, and the companion “Variant-Key” response header field to indicate which representation was selected. It is an augmentation of the “Vary” mechanism in HTTP caching."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">draft-nottingham-variants-01</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#variants">The “Variants” HTTP Header Field</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#vary">Relationship to Vary</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#variant-key">The “Variant-Key” HTTP Header Field</a></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#define">Defining Content Negotiation Using Variants</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#cache">Cache Behaviour</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#find">Find Available Keys</a></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#example-of-cache-behaviour">Example of Cache Behaviour</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#examples">Example Headers</a><ul><li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#single-variant">Single Variant</a></li><li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a href="#multiple-variants">Multiple Variants</a></li><li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a href="#partial-coverage">Partial Coverage</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgments">Acknowledgments</a></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#backports">Variants for Existing Content Negotiation Mechanisms</a><ul><li><a href="#rfc.section.A.1">A.1.</a>&nbsp;&nbsp;&nbsp;<a href="#content-encoding">Accept-Encoding</a></li><li><a href="#rfc.section.A.2">A.2.</a>&nbsp;&nbsp;&nbsp;<a href="#content-language">Accept-Language</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Fastly</td></tr><tr><td class="text-left">Updates: <a href="https://tools.ietf.org/html/rfc7234">7234</a> (if approved)</td><td class="text-right">October 30, 2017</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right"></td></tr><tr><td class="text-left">Expires: May 3, 2018</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>HTTP Representation Variants</h1><div class="filename">draft-nottingham-variants-01</div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This specification introduces the HTTP “Variants” response header field to communicate what representations are available for a given resource, and the companion “Variant-Key” response header field to indicate which representation was selected. It is an augmentation of the “Vary” mechanism in HTTP caching.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</a>.</p></div><div id="rfc.note.1.p.3"><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</a>.</p></div><div id="rfc.note.1.p.4"><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</a>.</p></div><div id="rfc.note.1.p.5"><p>See also the draft’s current status in the IETF datatracker, at <a href="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on May 3, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP proactive content negotiation (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 3.4.1) is starting to be used more widely again. The most widely seen use – determining a response’s content-coding – is being joined by renewed interest in negotiation for language and other, newer attributes (for example, see <a href="#I-D.ietf-httpbis-client-hints"><cite title="HTTP Client Hints">[I-D.ietf-httpbis-client-hints]</cite></a>).</p></div><div id="rfc.section.1.p.2"><p>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.1) using the Vary header (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.1.4), which identifies the request headers that form the secondary cache key for a given response.</p></div><div id="rfc.section.1.p.3"><p>HTTP’s caching model allows a certain amount of latitude in normalising request header fields identified by Vary to match those stored in the cache, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even with understanding of the headers’ semantics to facilitate such normalisation, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</p></div><div id="rfc.section.1.p.4" class="avoidbreakafter"><p>For example, if a cache has stored the following request/response pair:</p></div><div id="rfc.figure.u.1"><pre>
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
</pre></div><div id="rfc.section.1.p.5"><p>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, thereby incurring possibly unnecessary latency.</p></div><div id="rfc.section.1.p.6"><p>This specification introduces the HTTP Variants response header field (<a href="#variants" title="The “Variants” HTTP Header Field">Section&nbsp;2</a>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following an algorithm defined in <a href="#cache" title="Cache Behaviour">Section&nbsp;5</a>.</p></div><div id="rfc.section.1.p.7"><p>Its companion the Variant-Key response header field (<a href="#variant-key" title="The “Variant-Key” HTTP Header Field">Section&nbsp;3</a>) indicates which representation was selected, so that it can be reliably reused in the future.</p></div><div id="rfc.section.1.p.8"><p>This mechanism requires that proactive content negotiation mechanisms define how they use it; see <a href="#define" title="Defining Content Negotiation Using Variants">Section&nbsp;4</a>. It is best suited for negotiation over request headers that are well-understood. It also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</p></div><div id="rfc.section.1.p.9"><p>It can be seen as a simpler version of the Alternates header field introduced by <a href="#RFC2295"><cite title="Transparent Content Negotiation in HTTP">[RFC2295]</cite></a>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.1.p.2"><p>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> with a list extension, defined in Section 7 of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</p></div><div id="rfc.section.1.1.p.3"><p>Additionally, it uses the “field-name”, “OWS” and “token” rules from <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div></section></section><section id="variants"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#variants">The “Variants” HTTP Header Field</a></h2><div id="rfc.section.2.p.1"><p>The Variants HTTP response header field indicates what representations are available for a given resource at the time that the response is produced, by enumerating the request header fields that it varies on, along with the values that are available for each.</p></div><div id="rfc.figure.u.2"><pre>
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
</pre></div><div id="rfc.section.2.p.2"><p>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</p></div><div id="rfc.section.2.p.3" class="avoidbreakafter"><p>So, given this example header field:</p></div><div id="rfc.figure.u.3"><pre>
Variants: Accept-Encoding;gzip
</pre></div><div id="rfc.section.2.p.4"><p>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <a href="#content-encoding" title="Accept-Encoding">Appendix&nbsp;A.1</a>).</p></div><div id="rfc.section.2.p.5" class="avoidbreakafter"><p>Given:</p></div><div id="rfc.figure.u.4"><pre>
Variants: accept-encoding
</pre></div><div id="rfc.section.2.p.6"><p>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always, field-name is case-insensitive.</p></div><div id="rfc.section.2.p.7" class="avoidbreakafter"><p>A more complex example:</p></div><div id="rfc.figure.u.5"><pre>
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
</pre></div><div id="rfc.section.2.p.8" class="avoidbreakafter"><p>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7), they might occur in the same header field or separately, like this:</p></div><div id="rfc.figure.u.6"><pre>
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
</pre></div><div id="rfc.section.2.p.9"><p>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response (see <a href="#content-encoding" title="Accept-Encoding">Appendix&nbsp;A.1</a> for an example of this).</p></div><div id="rfc.section.2.p.10"><p>The ordering of the request header fields themselves indicates descending application of preferences; for example, in the headers above, a cache will serve gzip’d content regardless of language if it is available.</p></div><div id="rfc.section.2.p.11"><p>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</p></div><div id="rfc.section.2.p.12"><p>Likewise, servers MUST send the Variant-Key response header field when sending Variants.</p></div><section id="vary"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#vary">Relationship to Vary</a></h3><div id="rfc.section.2.1.p.1"><p>Caches that fully implement this specification SHOULD ignore request header fields in the <span class="tt">Vary</span> header for the purposes of secondary cache key calculation (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.1) when their semantics are implemented as per this specification and their corresponding response header field is listed in <span class="tt">Variants</span>.</p></div><div id="rfc.section.2.1.p.2"><p>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</p></div></section></section><section id="variant-key"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#variant-key">The “Variant-Key” HTTP Header Field</a></h2><div id="rfc.section.3.p.1"><p>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</p></div><div id="rfc.figure.u.7"><pre>
Variant-Key     = 1#available-value
</pre></div><div id="rfc.section.3.p.2"><p>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</p></div><div id="rfc.section.3.p.3"><p>Therefore, Variant-Key MUST be the same length (in comma-separated members) as Variants, and each member MUST correspond in position to its companion in Variants.</p></div><div id="rfc.section.3.p.4" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.8"><pre>
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
</pre></div><div id="rfc.section.3.p.5"><p>This header pair indicates that the representation is used for responses that have a “gzip” content-coding and “fr” content-language.</p></div><div id="rfc.section.3.p.6"><p>Note that the contents of Variant-Key are only used to indicate what request attributes are identified with the response containing it; this is different from headers like Content-Encoding, which indicate attributes of the response. In the example above, it might be that a gzip’d version of the French content is not available, in which case it will not include “Content-Encoding: gzip”, but still have “gzip” in Variant-Key.</p></div></section><section id="define"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#define">Defining Content Negotiation Using Variants</a></h2><div id="rfc.section.4.p.1" class="avoidbreakafter"><p>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</p></div><div id="rfc.section.4.p.2"><ul><li>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</li><li>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</li><li>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</li></ul></div><div id="rfc.section.4.p.3"><p><a href="#backports" title="Variants for Existing Content Negotiation Mechanisms">Appendix&nbsp;A</a> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</p></div></section><section id="cache"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#cache">Cache Behaviour</a></h2><div id="rfc.section.5.p.1"><p>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</p></div><div id="rfc.section.5.p.2" class="avoidbreakafter"><p>They do so by running this algorithm (or its functional equivalent) upon receiving a request, incoming-request:</p></div><div id="rfc.section.5.p.3"><ol><li>Let selected-responses be a list of the stored responses suitable for reuse as defined in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> Section 4, excepting the requirement to calculate a secondary cache key.</li><li>Order selected-responses by the “Date” header field, most recent to least recent.</li><li>If the freshest (as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.2) has one or more “Variants” header field(s): <ol><li>Select one member of selected_responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</li><li>Let sorted-variants be an empty list.</li><li>For each variant in variants-header: <ol><li>If variant’s field-name corresponds to the response header field identified by a content negotiation mechanism that the implementation supports: <ol><li>Let request-value be the field-value of the request header field(s) identified by the content negotiation mechanism.</li><li>Let available-values be a list containing all available-value for the variant.</li><li>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</li><li>Append sorted-values to sorted-variants.</li></ol></li></ol> At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</li><li>If any member of sorted-variants is an empty list, stop processing and forward the request towards the origin, since an acceptable response is not stored in the cache.</li><li>Let sorted-keys be the result of running Find Available Keys (<a href="#find" title="Find Available Keys">Section&nbsp;5.1</a>) on sorted-variants and two empty lists.</li></ol></li></ol></div><div id="rfc.section.5.p.4"><p>This will result in a list of lists, where each member of the top-level list indicates, in preference order, a key for an acceptable response to the request.</p></div><div id="rfc.section.5.p.5"><p>A Cache MAY satisfy the request with any response whose Variant-Key header corresponds to a member of sorted-keys; when doing so, it SHOULD use the most preferred available response.</p></div><div id="rfc.section.5.p.6"><p>See also <a href="#vary" title="Relationship to Vary">Section&nbsp;2.1</a> regarding handling of Vary.</p></div><section id="find"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#find">Find Available Keys</a></h3><div id="rfc.section.5.1.p.1" class="avoidbreakafter"><p>Given sorted-variants, a list of lists, and key-stub, a list representing a partial key, and possible-keys, a list:</p></div><div id="rfc.section.5.1.p.2"><ol><li>Let sorted-values be the first member of sorted-variants.</li><li>For each sorted-value in sorted-values: <ol><li>Let this-key be a copy of key-stub.</li><li>Append sorted-value to this-key.</li><li>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</li><li>If remaining-variants is empty, append this-key to possible-keys.</li><li>Else, run Find Available Keys on remaining-variants, this-key and possible-keys.</li><li>Return possible-keys.</li></ol></li></ol></div></section><section id="example-of-cache-behaviour"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#example-of-cache-behaviour">Example of Cache Behaviour</a></h3><div id="rfc.section.5.2.p.1" class="avoidbreakafter"><p>For example, if the selected variants-header was:</p></div><div id="rfc.figure.u.9"><pre>
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
</pre></div><div id="rfc.section.5.2.p.2" class="avoidbreakafter"><p>and the request contained the headers:</p></div><div id="rfc.figure.u.10"><pre>
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
</pre></div><div id="rfc.section.5.2.p.3" class="avoidbreakafter"><p>Then the sorted-variants would be:</p></div><div id="rfc.figure.u.11"><pre>
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
</pre></div><div id="rfc.section.5.2.p.4" class="avoidbreakafter"><p>Which means that the sorted-keys would be:</p></div><div id="rfc.figure.u.12"><pre>
[
  ['fr', 'gzip'], 
  ['fr', 'identity'], 
  ['en', 'gzip'], 
  ['en', 'identity']
]
</pre></div><div id="rfc.section.5.2.p.5" class="avoidbreakafter"><p>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</p></div><div id="rfc.figure.u.13"><pre>
Variant-Key: fr, gzip
</pre></div><div id="rfc.section.5.2.p.6"><p>it could be used to satisfy the first preference. If not, responses corresponding to the other keys could be returned, or the request could be forwarded towards the origin.</p></div></section></section><section id="examples"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#examples">Example Headers</a></h2><section id="single-variant"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a>&nbsp;<a href="#single-variant">Single Variant</a></h3><div id="rfc.section.6.1.p.1" class="avoidbreakafter"><p>Given a request/response pair:</p></div><div id="rfc.figure.u.14"><pre>
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
</pre></div><div id="rfc.section.6.1.p.2"><p>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <span class="tt">Content-Language</span> of “en”, and another whose <span class="tt">Content-Language</span> is “de”.</p></div><div id="rfc.section.6.1.p.3"><p>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</p></div><div id="rfc.section.6.1.p.4"><p>So, if a request with “en” in <span class="tt">Accept-Language</span> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</p></div><div id="rfc.section.6.1.p.5"><p>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <span class="tt">Variants</span> list.</p></div><div id="rfc.section.6.1.p.6"><p>Note that <span class="tt">Accept-Language</span> is listed in Vary, to assure backwards-compatibility with caches that do not support <span class="tt">Variants</span>.</p></div></section><section id="multiple-variants"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a>&nbsp;<a href="#multiple-variants">Multiple Variants</a></h3><div id="rfc.section.6.2.p.1" class="avoidbreakafter"><p>A more complicated request/response pair:</p></div><div id="rfc.figure.u.15"><pre>
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
</pre></div><div id="rfc.section.6.2.p.2"><p>Here, the cache knows that there are two axes that the response varies upon; <span class="tt">Content-Language</span> and <span class="tt">Content-Encoding</span>. Thus, there are a total of six possible representations for the resource, and the cache needs to consider the selection algorithms for both axes.</p></div><div id="rfc.section.6.2.p.3"><p>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</p></div></section><section id="partial-coverage"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a>&nbsp;<a href="#partial-coverage">Partial Coverage</a></h3><div id="rfc.section.6.3.p.1" class="avoidbreakafter"><p>Now, consider the previous example, but where only one of the Vary’d axes is listed in <span class="tt">Variants</span>:</p></div><div id="rfc.figure.u.16"><pre>
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
</pre></div><div id="rfc.section.6.3.p.2"><p>Here, the cache will need to calculate a secondary cache key as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.1 – but considering only <span class="tt">Accept-Language</span> to be in its field-value – and then continue processing <span class="tt">Variants</span> for the set of stored responses that the algorithm described there selects.</p></div></section></section><section id="iana-considerations"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.7.p.1" class="avoidbreakafter"><p>This specification registers two values in the Permanent Message Header Field Names registry established by <a href="#RFC3864"><cite title="Registration Procedures for Message Header Fields">[RFC3864]</cite></a>:</p></div><div id="rfc.section.7.p.2" class="avoidbreakafter"><ul><li>Header field name: Variants</li><li>Applicable protocol: http</li><li>Status: standard</li><li>Author/Change Controller: IETF</li><li>Specification document(s): [this document]</li><li>Related information:</li><li>Header field name: Variant-Key</li><li>Applicable protocol: http</li><li>Status: standard</li><li>Author/Change Controller: IETF</li><li>Specification document(s): [this document]</li><li>Related information:</li></ul></div></section><section id="security-considerations"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.8.p.1"><p>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <span class="tt">Variants</span> header by its nature will leak them.</p></div><div id="rfc.section.8.p.2"><p>Note that the <span class="tt">Variants</span> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <span class="tt">Variants</span>.</p></div></section><section id="acknowledgments"><h2 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#acknowledgments">Acknowledgments</a></h2><div id="rfc.section.9.p.1"><p>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <a href="#RFC2295"><cite title="Transparent Content Negotiation in HTTP">[RFC2295]</cite></a>. Thanks to its authors for their inspiration.</p></div><div id="rfc.section.9.p.2"><p>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</p></div><div id="rfc.section.9.p.3"><p>Thanks to Hooman Beheshti for his review and input.</p></div></section><section id="rfc.references"><h2 id="rfc.section.10"><a href="#rfc.section.10">10.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC4647">[RFC4647]</dt><dd>Phillips, A. and M. Davis, “<a href="https://tools.ietf.org/html/rfc4647">Matching of Language Tags</a>”, BCP&nbsp;47, RFC&nbsp;4647, <a href="http://dx.doi.org/10.17487/RFC4647">DOI&nbsp;10.17487/RFC4647</a>, September&nbsp;2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4647">https://www.rfc-editor.org/info/rfc4647</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP&nbsp;14, RFC&nbsp;8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI&nbsp;10.17487/RFC8174</a>, May&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-httpbis-client-hints">[I-D.ietf-httpbis-client-hints]</dt><dd>Grigorik, I., “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-04">HTTP Client Hints</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-client-hints-04 (work in progress), April&nbsp;2017.</dd><dt id="RFC2295">[RFC2295]</dt><dd>Holtman, K. and A. Mutz, “<a href="https://tools.ietf.org/html/rfc2295">Transparent Content Negotiation in HTTP</a>”, RFC&nbsp;2295, <a href="http://dx.doi.org/10.17487/RFC2295">DOI&nbsp;10.17487/RFC2295</a>, March&nbsp;1998, &lt;<a href="https://www.rfc-editor.org/info/rfc2295">https://www.rfc-editor.org/info/rfc2295</a>&gt;.</dd><dt id="RFC3864">[RFC3864]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>”, BCP&nbsp;90, RFC&nbsp;3864, <a href="http://dx.doi.org/10.17487/RFC3864">DOI&nbsp;10.17487/RFC3864</a>, September&nbsp;2004, &lt;<a href="https://www.rfc-editor.org/info/rfc3864">https://www.rfc-editor.org/info/rfc3864</a>&gt;.</dd></dl></section></section><section id="backports"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#backports">Variants for Existing Content Negotiation Mechanisms</a></h2><div id="rfc.section.A.p.1"><p>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.3) with the <span class="tt">Variants</span> header field.</p></div><section id="content-encoding"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1.</a>&nbsp;<a href="#content-encoding">Accept-Encoding</a></h3><div id="rfc.section.A.1.p.1"><p>This section defines handling for <span class="tt">Accept-Encoding</span> variants, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> Section 5.3.4.</p></div><div id="rfc.section.A.1.p.2" class="avoidbreakafter"><p>To perform content negotiation for Accept-Encoding given an request-value and available-values:</p></div><div id="rfc.section.A.1.p.3"><ol><li>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty.</li><li>If “identity” is not a member of preferred-codings, append “identity”.</li><li>Append “identity” to available-values.</li><li>Remove any member of available-values not present in preferred-codings, comparing in a case-insensitive fashion.</li><li>Return available-values.</li></ol></div></section><section id="content-language"><h3 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2.</a>&nbsp;<a href="#content-language">Accept-Language</a></h3><div id="rfc.section.A.2.p.1"><p>This section defines handling for <span class="tt">Accept-Language</span> variants, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> Section 5.3.5.</p></div><div id="rfc.section.A.2.p.2" class="avoidbreakafter"><p>To perform content negotiation for Accept-Language given an request-value and available-values:</p></div><div id="rfc.section.A.2.p.3"><ol><li>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> Section 5.3.1 (omitting any language-range with a weight of 0).</li><li>If preferred-langs is empty, append “*”.</li><li>Filter available-values using preferred-langs with either the Basic Filtering scheme defined in <a href="#RFC4647"><cite title="Matching of Language Tags">[RFC4647]</cite></a> Section 3.3.1, or the Lookup scheme defined in Section 3.4 of that document. Use the first member of available-values as the default.</li><li>Return available-values.</li></ol></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></div></div></div><script src="../Tools/bower_components/jquery/dist/jquery.min.js"></script><script src="../Tools/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></body></html>