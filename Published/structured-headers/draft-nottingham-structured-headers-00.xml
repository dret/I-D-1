<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-structured-headers-00" category="info">

  <front>
    <title>Structured Headers for HTTP</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <author initials="P-H." surname="Kamp" fullname="Poul-Henning Kamp">
      <organization>The Varnish Cache Project</organization>
      <address>
        <email>phk@varnish-cache.org</email>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes Structured Headers, a way of simplifying HTTP header field definition and parsing. It is intended for use by new HTTP header fields.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/structured-headers">https://github.com/mnot/I-D/labels/structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/structured-headers/">https://mnot.github.io/I-D/structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/structured-headers">https://github.com/mnot/I-D/commits/gh-pages/structured-headers</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in <xref target="RFC7231"/>, Section 8.3.1, there are many decisions – and pitfalls – for a prospective HTTP header field author.</t>

<t>Likewise, bespoke parsers often need to be written for specific HTTP headers, because each has slightly different handling of what looks like common syntax.</t>

<t>This document introduces structured HTTP header field values (hereafter, Structured Headers) to address these problems. Structured Headers define a generic, abstract model for data, along with a concrete serialisation for expressing that model in textual HTTP headers, as used by HTTP/1 <xref target="RFC7230"/> and HTTP/2 <xref target="RFC7540"/>.</t>

<t>HTTP headers that are defined as Structured Headers use the types defined in this specification to define their syntax and basic handling rules, thereby simplifying both their definition and parsing.</t>

<t>Additionally, future versions of HTTP can define alternative serialisations of the abstract model of Structured Headers, allowing headers that use it to be transmitted more efficiently without being redefined.</t>

<t>Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.</t>

<t>To specify a header field that uses Structured Headers, see <xref target="specify"/>.</t>

<t><xref target="types"/> defines a number of abstract data types that can be used in Structured Headers, of which only three are allowed at the “top” level: lists, dictionaries, or items.</t>

<t>Those abstract types can be serialised into textual headers – such as those used in HTTP/1 and HTTP/2 – using the algorithms described in <xref target="text"/>.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This document uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/>, including the DIGIT, ALPHA and DQUOTE rules from that document. It also includes the OWS rule from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="specify" title="Specifying Structured Headers">

<t>HTTP headers that use Structured Headers need to be defined to do so explicitly; recipients and generators need to know that the requirements of this document are in effect. The simplest way to do that is by referencing this document in its definition.</t>

<t>The field’s definition will also need to specify the field-value’s allowed syntax, in terms of the types described in <xref target="types"/>, along with their associated semantics.</t>

<t>Field definitions MUST NOT relax or otherwise modify the requirements of this specification; doing so would preclude handling by generic software.</t>

<t>However, field definitions are encouraged to clearly state additional constraints upon the syntax, as well as the consequences when those constraints are violated.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
# FooExample Header

The FooExample HTTP header field conveys a list of numbers about how
much Foo the sender has.

FooExample is a Structured header [RFCxxxx]. Its value MUST be a
dictionary ([RFCxxxx], Section Y.Y).

The dictionary MUST contain:

* A member whose key is "foo", and whose value is an integer
  ([RFCxxxx], Section Y.Y), indicating the number of foos in
  the message.
* A member whose key is "bar", and whose value is a string
  ([RFCxxxx], Section Y.Y), conveying the characteristic bar-ness
  of the message.

If the parsed header field does not contain both, it MUST be ignored.
]]></artwork></figure>

<t>Note that empty header field values are not allowed by the syntax, and therefore will be considered errors.</t>

</section>
<section anchor="text" title="Parsing Requirements for Textual Headers">

<t>When a receiving implementation parses textual HTTP header fields (e.g., in HTTP/1 or HTTP/2) that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</t>

<t>Given an ASCII string input_string that represents the chosen header’s field-value, return the parsed header value. Note that input_string may incorporate multiple header lines combined into one comma-separated field-value, as per <xref target="RFC7230"/>, Section 3.2.2.</t>

<t><list style="numbers">
  <t>Discard any OWS from the beginning of input_string.</t>
  <t>If the field-value is defined to be a dictionary, return the result of Parsing a Dictionary from Textual headers (<xref target="dictionary"/>).</t>
  <t>If the field-value is defined to be a list, return the result of Parsing a List from Textual Headers (<xref target="list"/>).</t>
  <t>If the field-value is defined to be a parameterised label, return the result of Parsing a Parameterised Label from Textual headers (<xref target="param"/>).</t>
  <t>Otherwise, return the result of Parsing an Item from Textual Headers (<xref target="item"/>).</t>
</list></t>

<t>Note that in the case of lists and dictionaries, this has the effect of combining multiple instances of the header field into one. However, for singular items and parameterised labels, it has the effect of selecting the first value and ignoring any subsequent instances of the field, as well as extraneous text afterwards.</t>

<t>Additionally, note that the effect of the parsing algorithms as specified is generally intolerant of syntax errors; if one is encountered, the typical response is to throw an error, thereby discarding the entire header field value. This includes any non-ASCII characters in input_string.</t>

</section>
<section anchor="types" title="Structured Header Data Types">

<t>This section defines the abstract value types that can be composed into Structured Headers, along with the textual HTTP serialisations of them.</t>

<section anchor="number" title="Numbers">

<t>Abstractly, numbers are integers with an optional fractional part. They have a maximum of fifteen digits available to be used in one or both of the parts, as reflected in the ABNF below; this allows them to be stored as IEEE 754 double precision numbers (binary64) (<xref target="IEEE754"/>).</t>

<t>The textual HTTP serialisation of numbers allows a maximum of fifteen digits between the integer and fractional part, along with an optional “-“ indicating negative numbers.</t>

<figure><artwork type="abnf"><![CDATA[
number   = ["-"] ( "." 1*15DIGIT /
             DIGIT "." 1*14DIGIT /
            2DIGIT "." 1*13DIGIT /
            3DIGIT "." 1*12DIGIT /
            4DIGIT "." 1*11DIGIT /
            5DIGIT "." 1*10DIGIT /
            6DIGIT "." 1*9DIGIT /
            7DIGIT "." 1*8DIGIT /
            8DIGIT "." 1*7DIGIT /
            9DIGIT "." 1*6DIGIT /
           10DIGIT "." 1*5DIGIT /
           11DIGIT "." 1*4DIGIT /
           12DIGIT "." 1*3DIGIT /
           13DIGIT "." 1*2DIGIT /
           14DIGIT "." 1DIGIT /
           15DIGIT )

integer  = ["-"] 1*15DIGIT
unsigned = 1*15DIGIT
]]></artwork></figure>

<t>integer and unsigned are defined as conveniences to specification authors; if their use is specified and their ABNF is not matched, a parser MUST consider it to be invalid.</t>

<t>For example, a header whose value is defined as a number could look like:</t>

<figure><artwork><![CDATA[
ExampleNumberHeader: 4.5
]]></artwork></figure>

<section anchor="parsing-numbers-from-textual-headers" title="Parsing Numbers from Textual Headers">

<t>TBD</t>

</section>
</section>
<section anchor="string" title="Strings">

<t>Abstractly, strings are ASCII strings <xref target="RFC0020"/>, excluding control characters (i.e., the range 0x20 to 0x7E). Note that this excludes tabs, newlines and carriage returns. They may be at most 1024 characters long.</t>

<t>The textual HTTP serialisation of strings uses a backslash (“") to escape double quotes and backslashes in strings.</t>

<figure><artwork type="abnf"><![CDATA[
string    = DQUOTE 1*1024(char) DQUOTE
char      = unescaped / escape ( DQUOTE / "\" )
unescaped = %x20-21 / %x23-5B / %x5D-7E
escape    = "\"
]]></artwork></figure>

<t>For example, a header whose value is defined as a string could look like:</t>

<figure><artwork><![CDATA[
ExampleStringHeader: "hello world"
]]></artwork></figure>

<t>Note that strings only use DQUOTE as a delimiter; single quotes do not delimit strings. Furthermore, only DQUOTE and “" can be escaped; other sequences MUST generate an error.</t>

<t>Unicode is not directly supported in Structured Headers, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.</t>

<t>When it is necessary for a field value to convey non-ASCII string content, binary content (<xref target="binary"/>) SHOULD be specified, along with a character encoding (most likely, UTF-8).</t>

<section anchor="parsing-a-string-from-textual-headers" title="Parsing a String from Textual Headers">

<t>Given an ASCII string input_string, return an unquoted string. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let output_string be an empty string.</t>
  <t>If the first character of input_string is not DQUOTE, throw an error.</t>
  <t>Discard the first character of input_string.</t>
  <t>If input_string contains more than 1025 characters, throw an error.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let char be the result of removing the first character of input_string.</t>
      <t>If char is a backslash (“\”):
      <list style="numbers">
          <t>If input_string is now empty, throw an error.</t>
          <t>Else:
          <list style="numbers">
              <t>Let next_char be the result of removing the first character of input_string.</t>
              <t>If next_char is not DQUOTE or “\”, throw an error.</t>
              <t>Append next_char to output_string.</t>
            </list></t>
        </list></t>
      <t>Else, if char is DQUOTE, remove the first character of input_string and return output_string.</t>
      <t>Else, append char to output_string.</t>
    </list></t>
  <t>Otherwise, throw an error.</t>
</list></t>

</section>
</section>
<section anchor="label" title="Labels">

<t>Labels are short (up to 256 characters) textual identifiers; their abstract model is identical to their expression in the textual HTTP serialisation.</t>

<figure><artwork type="abnf"><![CDATA[
label = lcalpha *255( lcalpha / DIGIT / "_" / "-"/ "*" / "/" )
lcalpha = %x61-7A ; a-z
]]></artwork></figure>

<t>Note that labels can only contain lowercase letters.</t>

<t>For example, a header whose value is defined as a label could look like:</t>

<figure><artwork><![CDATA[
ExampleLabelHeader: foo/bar
]]></artwork></figure>

<section anchor="parsing-a-label-from-textual-headers" title="Parsing a Label from Textual Headers">

<t>Given an ASCII string input_string, return a label. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>If input_string contains more than 256 characters, throw an error.</t>
  <t>If the first character of input_string is not lcalpha, throw an error.</t>
  <t>Let output_string be an empty string.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let char be the result of removing the first character of input_string.</t>
      <t>If char is not one of lcalpha, DIGIT, “_”, “-“, “*” or “/”:
      <list style="numbers">
          <t>Prepend char to input_string.</t>
          <t>Return output_string.</t>
        </list></t>
      <t>Append char to output_string.</t>
    </list></t>
  <t>Return output_string.</t>
</list></t>

</section>
</section>
<section anchor="param" title="Parameterised Labels">

<t>Parameterised Labels are labels (<xref target="label"/>) with up to 256 parameters; each parameter has a label and an optional value that is an item (<xref target="item"/>). Ordering between parameters is not significant, and duplicate parameters MUST be considered an error.</t>

<t>The textual HTTP serialisation uses semicolons (“;”) to delimit the parameters from each other, and equals (“=”) to delimit the parameter name from its value.</t>

<figure><artwork type="abnf"><![CDATA[
parameterised = label *256( OWS ";" OWS label [ "=" item ] )
]]></artwork></figure>

<t>For example,</t>

<figure><artwork><![CDATA[
ExampleParamHeader: abc; a=1; b=2; c
]]></artwork></figure>

<section anchor="parsing-a-parameterised-label-from-textual-headers" title="Parsing a Parameterised Label from Textual Headers">

<t>Given an ASCII string input_string, return a label with an mapping of parameters. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let primary_label be the result of Parsing a Label from Textual Headers (<xref target="label"/>) from input_string.</t>
  <t>Let parameters be an empty mapping.</t>
  <t>In a loop:
  <list style="numbers">
      <t>Consume any OWS from the beginning of input_string.</t>
      <t>If the first character of input_string is not “;”, exit the loop.</t>
      <t>Consume a “;” character from the beginning of input_string.</t>
      <t>Consume any OWS from the beginning of input_string.</t>
      <t>let param_name be the result of Parsing a Label from Textual Headers (<xref target="label"/>) from input_string.</t>
      <t>If param_name is already present in parameters, throw an error.</t>
      <t>Let param_value be a null value.</t>
      <t>If the first character of input_string is “=”:
      <list style="numbers">
          <t>Consume the “=” character at the beginning of input_string.</t>
          <t>Let param_value be the result of Parsing an Item from Textual Headers (<xref target="item"/>) from input_string.</t>
        </list></t>
      <t>If parameters has more than 255 members, throw an error.</t>
      <t>Add param_name to parameters with the value param_value.</t>
    </list></t>
  <t>Return the tuple (primary_label, parameters).</t>
</list></t>

</section>
</section>
<section anchor="binary" title="Binary Content">

<t>Arbitrary binary content up to 16K in size can be conveyed in Structured Headers.</t>

<t>The textual HTTP serialisation indicates their presence by a leading “*”, with the data encoded using Base 64 Encoding <xref target="RFC4648"/>, without padding (as “=” might be confused with the use of dictionaries).</t>

<figure><artwork type="abnf"><![CDATA[
binary = "*" 1*21846(base64)
base64 = ALPHA / DIGIT / "+" / "/"
]]></artwork></figure>

<t>For example, a header whose value is defined as binary content could look like:</t>

<figure><artwork><![CDATA[
ExampleBinaryHeader: *cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg
]]></artwork></figure>

<section anchor="parsing-binary-content-from-textual-headers" title="Parsing Binary Content from Textual Headers">

<t>Given an ASCII string input_string, return binary content. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>If the first character of input_string is not “*”, throw an error.</t>
  <t>Discard the first character of input_string.</t>
  <t>Let b64_content be the result of removing content of input_string up to but not including the first character that is not in ALPHA, DIGIT, “+” or “/”.</t>
  <t>Let binary_content be the result of Base 64 Decoding <xref target="RFC4648"/> b64_content, synthesising padding if necessary. If an error is encountered, throw it.</t>
  <t>Return binary_content.</t>
</list></t>

</section>
</section>
<section anchor="item" title="Items">

<t>An item is can be a number (<xref target="number"/>), string (<xref target="string"/>), label (<xref target="label"/>) or binary content (<xref target="binary"/>).</t>

<figure><artwork type="abnf"><![CDATA[
item = number / string / label / binary
]]></artwork></figure>

<section anchor="parsing-an-item-from-textual-headers" title="Parsing an Item from Textual Headers">

<t>Given an ASCII string input_string, return an item. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Discard any OWS from the beginning of input_string.</t>
  <t>If the first character of input_string is a “-“ or a DIGIT, process input_string as a number (<xref target="number"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is a DQUOTE, process input_string as a string (<xref target="string"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is “*”, process input_string as binary content (<xref target="binary"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is an lcalpha, process input_string as a label (<xref target="label"/>) and return the result, throwing any errors encountered.</t>
  <t>Otherwise, throw an error.</t>
</list></t>

</section>
</section>
<section anchor="dictionary" title="Dictionaries">

<t>Dictionaries are unordered maps of key-value pairs, where the keys are labels (<xref target="label"/>) and the values are items (<xref target="item"/>). There can be between 1 and 1024 members, and keys are required to be unique.</t>

<t>In the textual HTTP serialisation, keys and values are separated by “=” (without whitespace), and key/value pairs are separated by a comma with optional whitespace.</t>

<figure><artwork type="abnf"><![CDATA[
dictionary = label "=" item *1023( OWS "," OWS label "=" item )
]]></artwork></figure>

<t>For example, a header field whose value is defined as a dictionary could look like:</t>

<figure><artwork><![CDATA[
ExampleDictHeader: foo=1.23, da="Applepie", en=*w4ZibGV0w6ZydGUK
]]></artwork></figure>

<t>Typically, a header field specification will define the semantics of individual keys, as well as whether their presence is required or optional. Recipients MUST ignore keys that are undefined or unknown, unless the header field’s specification specifically disallows them.</t>

<section anchor="parsing-a-dictionary-from-textual-headers" title="Parsing a Dictionary from Textual Headers">

<t>Given an ASCII string input_string, return a mapping of (label, item). input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let dictionary be an empty mapping.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let this_key be the result of running Parse Label from Textual Headers (<xref target="label"/>) with input_string. If an error is encountered, throw it.</t>
      <t>If dictionary already contains this_key, raise an error.</t>
      <t>Consume a “=” from input_string; if none is present, raise an error.</t>
      <t>Let this_value be the result of running Parse Item from Textual Headers (<xref target="item"/>) with input_string. If an error is encountered, throw it.</t>
      <t>Add key this_key with value this_value to dictionary.</t>
      <t>Discard any leading OWS from input_string.</t>
      <t>If input_string is empty, return dictionary.</t>
      <t>Consume a COMMA from input_string; if no comma is present, raise an error.</t>
      <t>Discard any leading OWS from input_string.</t>
    </list></t>
  <t>Return dictionary.</t>
</list></t>

</section>
</section>
<section anchor="list" title="Lists">

<t>Lists are arrays of items (<xref target="item"/>) or parameterised labels (<xref target="param"/>, with one to 1024 members.</t>

<t>In the textual HTTP serialisation, each member is separated by a comma and optional whitespace.</t>

<figure><artwork type="abnf"><![CDATA[
list = list_member 1*1024( OWS "," OWS list_member )
list_member = item / paramterised_label
]]></artwork></figure>

<t>For example, a header field whose value is defined as a list of labels could look like:</t>

<figure><artwork><![CDATA[
ExampleLabelListHeader: foo, bar, baz_45
]]></artwork></figure>

<t>and a header field whose value is defined as a list of parameterised labels could look like:</t>

<figure><artwork><![CDATA[
ExampleParamListHeader: abc/def; g="hi";j, klm/nop
]]></artwork></figure>

<section anchor="parsing-a-list-from-textual-headers" title="Parsing a List from Textual Headers">

<t>Given an ASCII string input_string, return a list of items. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let items be an empty array.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let item be the result of running Parse Item from Textual Headers (<xref target="item"/>) with input_string. If an error is encountered, throw it.</t>
      <t>Append item to items.</t>
      <t>Discard any leading OWS from input_string.</t>
      <t>If input_string is empty, return items.</t>
      <t>Consume a COMMA from input_string; if no comma is present, raise an error.</t>
      <t>Discard any leading OWS from input_string.</t>
    </list></t>
  <t>Return items.</t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This draft has no actions for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>TBD</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC0020" target='https://www.rfc-editor.org/info/rfc20'>
<front>
<title>ASCII format for network interchange</title>
<author initials='V.G.' surname='Cerf' fullname='V.G. Cerf'><organization /></author>
<date year='1969' month='October' />
</front>
<seriesInfo name='STD' value='80'/>
<seriesInfo name='RFC' value='20'/>
<seriesInfo name='DOI' value='10.17487/RFC0020'/>
</reference>



<reference  anchor="RFC4648" target='https://www.rfc-editor.org/info/rfc4648'>
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<date year='2006' month='October' />
<abstract><t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4648'/>
<seriesInfo name='DOI' value='10.17487/RFC4648'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="IEEE754" target="http://grouper.ieee.org/groups/754/">
  <front>
    <title>IEEE Standard for Floating-Point Arithmetic</title>
    <author >
      <organization>IEEE</organization>
    </author>
    <date year="2008"/>
  </front>
</reference>




<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
H4sIAAB39lkAA81c+3PbOJL+nX8FTqmrtbN6WLJsZ+zz3TqxnXgnD2/izNTM
3JQLEiEJY4rkEKQVjyvzt28/ABKUKD/i29rz1NgSCQKNRvfXXzfAdDqdINd5
pPbFpzwrxnmRqVC8UTJUmRGTJBNvLi7OAzkaZep6PwiTcSzn0DjM5CTvxEme
63g6k/OOKZ/uzPjpztZWEMocGg+2+nvBGD5Ok+xmX+h4kgSBTrN9AQ+ZfLC1
9d3WIJCZkvvitYpVJqNgkWRX0ywp0v3gSt3At3BfnMW5ymKVd45x9CAwuYzD
SxklMQxyo0yQ6n3xS56M2wJ+6ThUcd4WJsnyTE0MfLqZ2w95psdwa5zMU2k/
zKEx3NJxpGP1axDIIp8l2X4gOoGAHx2bffGuK96XU6bLrI13MrtavpNkUxnr
P2Suk3hfnEqTRzd0Q82ljvbFHJT3N/zVhRnRjSID8Wd5npr9Xm+xWHTd3V5N
iPPOm674Xs5TT4DzpIg6b1QcgwDVvboIFzMlfpBZrM1MvJJj+HaeJb+pce5L
lc6u/nbNjTpjbNSFToIgTrI5dHOt9mHhYPnKb0KcnZyc7O0M96mXXGZTlfMs
YBK0gCrraqWoI75getC+x+3Z9LAPsD9YTZmFZHWnUSJRm53zRMe5OMp0Ppur
XI/psXJt4Ic1szxZ7JFuOAvcehEEQafTEXIEqw+LHgQXM20EWHSBSy9CZcaZ
HinT4AhtIcVC3ohkIoyep5Ge3KCi0TUEW7uYaBWF0MlExxpFEDAZkcrMQMOu
OMsFjAUzUWCUPMPCKDG6EbFarPZjulZYMAB1+R5/5cnlRxYmCJ5/PH0lTo7P
Lj58hBWLlISuMjVPrpXIcU4GFhVFGCkYSIm0GEV6TIp5jrNWIIspYKKRNjnJ
Qk+RS4uxxOfgagHyy1z8lzPIKaxAMeqCp/TQLntnneNeJEcqMr1V3//vLg80
T2CETI1RwRvJBKbfFkVMApmZCjftoDC6PxTZvR1PJzTS6hA9HOMjdz2eyXgK
EwIIoUmp+0VHj9e56U1nnVTCs2sm8UkpISOTgIoUC/sXI8ZFluGwgD95gctK
d89OLk7R3CSa15XKwGjyoJTBuwHukE/IHcD4eg9AUpoqmsNch2GkguAZQmGW
hAWtM0iZqrG1SZTE3MS5/ILW2mxdpO9YAGyCOxpwWnN1INS1isUCNEVdTAsd
yniscHK3t/8DBrc32O5//doWn6xxvehud/ttbAxKR8XPZXwDDjDWBm4bga6G
LqDziYwi+o6mJkWaJSbFTsBcVz2IXRvm+1ZfqYU2qg3maNLkSpE3YVQiO4Kp
wSrnCRrrAtABL2H/hlShx37XBvsYS/Q4BZgmZhJ8JNLTGUCyCPVkomg5wYjC
CHUIilvMwICiJLlCL4Gx0Vxg0qzZ7jJ2aLsaYILGA4+VyV3LCP1uA3UGq442
sgo2mzgrGYaZMgbVC1KDykaRmptuU5AmzIElEFMMnRqCn4M4cL9QRaQWND+4
AaFyyossYUrxOFM5mAs8JcFtCCGotfqS4uhsT9L1g3auvuSFjJaUC+oE3YYI
Z3ij169MZuvrVzIDuj5w13eGcB206HfDI6Eh8YRC7LZhuriKaKH5TapM2ZZ8
EKHPLj/PBRRptQNP6Mw5Bgo0kgaMpFzyrIiUsdYM0/BRfpSwT8Dza+A9CI7C
kC6Dpd+0xaRAkcU1iEuuAPZEM0VsdasVIZWhIFrXP7XG+S0tIlxtjEtRlCxQ
ypoWUUc6t94BvcRmjh4SQl8gl5qAgjTYLVg/2kJS5NCOtKCsPmFKGHW4N00A
DQiFNpbIiCX07R8Gco8uAZD6AnC8FCvNATWaK4RtbeamjL2hQP3DWqIZJDHI
V4ZMnguZGdlvbb5grxDhNE4oSckdCbDn6KiJtYkbkL7mjE5TzQHfAPDf3tpH
yVhvb8nkwKB5poChIi7mI+gQJlouF3qaNU4awQZUkhxm1jQW4Y0GYKIp57NM
MaLS4nIsQ4W18iRtiQiAGogahjl4NNSExjLTaL7gujpHnECASoxnRCyQlcUZ
HEmEqrJe7XQKUG0KEEfiFLAbJ7z1bs+hoWlhXNyRERB8JGr+ilIAwRFIicGz
Z0iUJTuLeJXEEHbI7pkwANcXSPaNaL37/Omi1ea/4v0H+vzx5B+fzz6eHOPn
T2+O3r4tP7gWn958+Pz2uPrE1wN48tWHd+9O3h/zw3BVLF16d/QT/MG5tT6c
X5x9eH/0tlXiSmnquC5si2iaWYoIilAV1Gb88tW56A9h4v8BcDfo978Dq+Ev
L/p7Q/iymCEVwsFozfkr6BCsNE2VzLATWH5YMQigQEAQZAMzSxYxuchKBCI7
xjU4KqZ4AcR4CWSjMJ33sgA6DYxdbBy9fH+6iY7M6AhmxzLtDLaHGNp1PI6K
0K3m8dnrs4u2OHp7/uaIJD3+x+cPFycMlWKSJXM2cCcDsVziStyPFejDj5/o
EX6CB+TAQOYgPO7SgPa3z5wLNkULxLmGhzxq4OIDRgJAgsSDigMkpjpFIDQ0
P4qfMk+8Hq7iZMFD4VQy9XuhgWjTEysgiJYBqwboCuSmS+kWhREFFBiTBxaB
EdVgrIRcFInHmBVe5xPgx8YLN5ZOE3D9xb8BYAhWQlp3Mju4y90DHaId8JjD
E4bnNgf0bF6GHBdS667LoFcjDxwNpTGQZUu0NQPpI7jxGBhKEJwupUJGOBeG
KUcYFwAxMdIivcPw5qRt1G8toh+AjlBdMN0FpLwQgmEN0daqSA6KtUQIWk3y
hSRveQMTv0a+tZyncdIAq5AUGeQBpMExpFQZeCXye4VUzMZ2pEyIpxrlK9Ik
9oIdsaCFwsVgu8e2MB/oGXSK/m2x1O8Dh77WSYQ6BCFPiXpJtBnIs//8809w
j9MkOeFL1rzZEvzLKzRzjKh6g/GJMjzMAyhOwZURBnuAkWCOAA+98BQwxmbI
i0mKsmvME3wHs6P8Ai78BX5+RZc3zGp5jcHjZFDGpBuxUTatEoefuj9tWnv2
WtLjIHgOmoHJPxdHQBAouC5IbRgYQJzWJEksSvN1HpwTGkTkKWhIrB0XbT4k
W7IgVwVw6BhTOXiYyYkxYA7d9YKMZLZGECovxdM7xeAlclIAEcIoDUYLZGkM
3DTrAL8w0IP1zFKc4IwvUC4ULhUfEsU0zaqRmGsb6ZtbGz2NgQCCqaFteQxP
zdP8pjFVQQsl5mehY3RTt/k4ZM5MhQbCohGbuIauoL3KMsBTRvpzpsvio+/m
mG5cuKyiBH3iC0HwI7qNpAKCvsZHCU/xQY5gpAXTlJW4THdDdafdtsddbEWz
N9isEg5E+dgGjCZ+xgQYxk6yXCLdZV4HTyK9llcUyo2XCvvEUIVT0Ig0Ph/k
XJQIRJJCzBnpSMMCoPtjFm7UuMjwQpX3Xfh1HQuJNsCWrIsTPYuPoPLXGjuD
4Y4+vTo7s1YJo6ZFfmm/kESZwmyPVoONEcw5tnqEqOHFkDa0Bd3EDSZI96k8
6rIGf5y5RCo/TjJQIWLqvIhyjQhjn46IT0OSPbLZHCxGEnPaLTtGwVgUZ2qy
gMpBebVcs3Kz7e4A/guCflccazPGuiLWJ5CNWOqCqzfVXDKFdfLl7QYDgLbJ
cghFK/AIBYKdB2E15YBCYYrYr7N6CXKUaEciXCzR7o3b26q3r18BJLcfKgXi
/L3jv6Vynz/ym2pk7IHGHD50TFyTuSLQgqtUCrxXhPPaM2/xmbW6oP5JpJ2u
+OD4wn1DxBCS1HztNDE9oj79/JY7Qx/FriizImSrJ1fERmY2ujPLw+ZstGTk
zqh1jDsTGPctfNeQ1Rl3V1SkBAtX0EURSZvBufrCsoYZjValMCpCw7fxZKIz
WGpeOeyIcJ/VA6ymGDExyVcFJQlrVAZUmMlYUZ0QPgsqWwGpohp1vewRlxqt
y+bAggSoUkRZcjv0eGPpd8RJfxLB55inxsUEjiQHQk8IGeABIm2IoSpsO/4K
sT1Cs0iRfWEjqgRkwOLBMqiLqsgTMi44pWEemqmGKGjRt8xqUIlxEncYVsvY
TYXgOopQfrMcUMQxVgguiGtDpCN6bdM5B/CuwFCrA/FyrlYWcBMrKXP55iKR
z9zr4bKx+ISFE0zULWu8fcbhDMQ8stLQejtSmSlHvYwtLsZYh2HOPMHm/BGM
gBMj4BryGjFkLr/oeTEn/qXBsiDuhHqKuY+8lhosPlJ+5UdT0RrjJBXlKtvK
uQoJPATdwNUDIRuGjBeeBu5ywP5LPIYUO7cdmxwpET5Nu1B7O0OIoQUOjLkF
FbPLmW6ApwM27w43EUvszhfDycWdiq1xcBbhrsmPVL5QiqdgNUt+vKTLekHX
03mr0/KJbqymXGm0InQpuQDLiieBJSpCHIpf4LFfxYZodVui/7y/QwUA0bP7
a/aHL9omw6Ymg1qT7aYm27Umg6Ymw1qTflOTnVqTraYmu36T75pa7PktXjS1
eOG32Gtq8Z3fYrehhROOWzQp1s2QWzTptV/Ta5Na+zW1Nmm172u16b4VbRN3
ednsSrsoLSIogN1PkQkcehcpo/BttWy1VNKnzCfWnBeX5QpXseftH4Z5rjIU
jONVqLA5B9wi77al6bnMxzMMBNLuE5UZJaUiVTlcxwCkeindblfF4aVszpO8
ZPVjKj3g7hBtDtlc3SbNDJqMvfti2N1h1QCeVhmQA9YmlgJQ8vKYC6WfKIxQ
EYw+LeGvsbdRwT7FN7bKtrU1IEqsvriyHiaGWRL5MWtDd1WXw2eGm6hi68tg
C1W19WXvZNMn9ISf3BeuHMSlNu4vMnXHRYFgCpA3VZahGQv1yP2RMOa8G9zf
Ggx9ARDBHoSfbnJU6pSQJI+vTCTNTGy0/rdFm2YK4nmqHHz/XoDoxm722LaK
grTtyYdBm6cItHdb50RMGQw3UNRNey3AL+wqh2DgPF4oem7kDfdsT4BM4EZV
m0Pxn6DYzqAP9+DTdmfnJX3aOe7snQT2eeoXnmSTebx92lncaZ9sVM4+WzPg
eVhMy6KwtVwWcBqnEjX6oZ0djRWqSM+Bq2YHRF0rhYcJOaS9XypbnBYZMi/c
gmpzl647LLmDuiyfsRo74BqhqIpo5NC2SKtKPger+DnW4yRUDgpCoHHoIcB0
U0zZ12+8uF1hnXNKXt/SWcnP+dgEVz06HQ67E7VAp1Bp7na9/YS41IYtbcJI
XVvWsLtqaoylHUwJaXPco51UiaQykcc2yxXGfTEgAExI3HdkJXwFSImwGyDI
cRx4Lm8BOzckLk0QsUFOimaDEPP54rTzYrO7BF/SItMa/Lq/7lAmcdCoiMlu
QtuuWy8cgIqoQKw58SxPuZTlB2bolOe/VZAvFLn39IjNhKpbTZk9ZkmVDpaK
AM6c2ErbS2kEJeeusvCA3lxiXRvBFuoM78uCz8UIjzsePK4OC8nwjzNNWeaq
rDRVOhdl9UGANVJL2TKpsZ4s3iE49MZKo870CvgC+u5bFtFfnSNJtmDJVmfD
j0H3J5FR+xUXseLHYFuX/0dzKIc6m3j91hYZMwuczzo54QdW/ShNFSBA1Qfm
877dUfNtnlMbmYwbyZmSZ8b3GSFijXWW1TGGbgzJIq2RZrdWP1meGlENKsUg
06AqAxANewG5hQFGBtBSpNj1YGfXM8/NMmZrPGyJfmq393F/qH6CAVNoaoQp
Om/Q6+qoSRK7nG09C/ADNskJ0TKC3tKZFM8HOzsb5beezVMgDl+28HenBb+e
08ceBmbXEMPybr+zdyQOhOz8sRwBueZCkYkilqusYzE8o4JRpPKcU6rHh2ue
w53RmpbBBetJkvRGMmsglLKplvZNgMxCPQGFH4BxdRtatchHQ7RdzUaMflhU
GP77URVHourGpJqP3YMHI26jDbfJhhGkei0Pcs8zVXP/JuiDsT6ug5EK09YA
yM66hwk7Goq6iCRcvw2Cxtt0UpM/YvGZQAcoC/GSCmjKAihgCp3cKy9QCdR5
EGKkX/6w9MnutOPGIJaEveqv+JCBZ7AtcKWlGsktBWavlJcizaJqcJHSMVrl
N3Y7a96Wl4es9yQ1xDiNmgN7jZA8brQOOJFx3Nl6mBuMvJv0QNSYxQJiKVGL
rcM7nqVj4vy8dju2PprWK82HVq+AqbsbtGUCgtFfvv6LgMFYqb8Clq4kKzUE
o+V3CCZHY8DZw/6BGB0ODsSYn60j2b17BE/AtbJUNoeIaTd+KgU/kXummZ4D
9b7kkVbg4SFYXXMGXq7lbSkaqbIJH8zspHjfiOacJKnDrVdgYcVcPWoXrMSo
R2AxmAqWHKwFogQOY0oJyJyqjh4oyfCb5wDwFTmtXZIn/EsWB0baJW15A1HJ
OYPncTOXNlmR5lTr18g097xVvmQwG/GmchQ5o8PC5GOWBjzWixhOkXSs8NBf
DLt7c7dC2S4aZHzSptwanX5X6ZRNHqHfJxM79oBGszK3ILiFob8m4Mteb+W2
CE/CmxCxgo/VbmNe4ObeRs3N215XNk8WLzknf2Vz8ttnNiUPgqNspIESw82l
vJ1DXn/3eypP6T9UtbmDBYB1FYz7Q4zdBeC9JKDbbIRjevUE8AG6wQUCVtGu
FEEnWKkgACPx6c6XSHV3h+LElQm4wjjcHb7ACqM7RZziWSksIkgyODHHM/Z2
GpPq7C4OUvBmq7/FuulHJKugQ2I8/eeD/ovh7sYIxNgdbgb8F27y4USP7f/V
Uvxvq6AtrcqdzJxX2QW25+M3f4/C1z8UP796uSVfR3+c0f9/T0fz0xv16eVv
o8HO1s8/7my9na7GvCWDeXKwq0/jaVz+Mcj/vCFxHjyySmIZ+2h3eOmWYT3R
di2WBWJ3GoFFolz1Y63LEjiayC3Zoiri/VdHtwkMSDJS7nrhnKscqwZX8efV
pp3tmTKajMD5jp5URUFaAafLhi1vVDVWFCt+XpfOAtIZnSi4fUY4CyhkCbEu
D4SXVU8AY7vV+3XTbTDgRbv/gBeZ3fihELdj15chfaemYQ/dYD03QM922rP9
NCW4d4SQx1YcUYonOMVTjxPd60uS9m+pHGzNMM0StIilypBpXje/ZFSZpjUX
dwiET1P49lQ/bfQAIV0xa71wDfbzzcINH0V2EInWyXVXyfxbpdt5lOriKsFf
r7xVP3uCcPeV/469MAxA4R1DC4LaPczbizjJONWFhIOOjFypm46jTxp52IKO
Qub8QsfabN/u5PpnTfnwk5+qX1BXFqhcus7voNBWYsn98Eo5mt1vKd8bivXv
5L9n99UY27aPuHYEtjqBCLwJmc2GozyLGUhqUjlWm6UIPU8Xq49LPtXIVKis
WVT9+IDpHZB2SXmZeuP25LZNz9t+el62aEjNl1+Cuqs86Q1+JxNCA/FKlIf9
7mC7DSzysHWUwu1UK8wI48Pni+HPevT6h63F7s834evP37N4F3xqC7ebloSr
Hw2g08X+S2bunQP2sVBf6xDXFNevdoQNjJF2EpcYsDaVleAbCXYlMJSWr4VQ
eYdPTbNdlGeGi9jpCt/ljukIMb7bHNm3Nmsz+cvyi4nlt4jeQDXesaTVzbZ1
50a/rQ7iVT42bAqDxrL5xOKHZyyNJYnBowqseNbgEk/ar3K/gkMsqkc9NFkn
V6tF5AcSq7IA4k3P5fNlYdsJC0qW+EZLLf0c1Ooe4JkrSS6ddYntmUZbJGjs
atvTzZqMu66dByXdT9HNkHNrXKhyxag/V4EtJcXCZKlCNxufSblUtGRUTfWf
hr1Fu69ozXtpjB1f+fiy39Fa9VtQvmcJdh8l9HZJy325eL+NDhnfPqNj1/iy
u7GvA8kskzcMaUuhEIGm6USwd1baJvFoS1hO8MLjw0If1Zbt2y50HLUhbNE7
i3dHLXrr6JAOUl/a3uxhmnq08u5vBv63Q45fPZ6vnS4XXJ4W0tz7UG5f796t
N1wYL7a18d0c/PXH5dAe7KLNh8dL0LiSd8pDdXFfHjka96DvAzE9bM106+A3
4C7RvBcnafMO4brj/48tpNsZ8JvGT4sabON+wCD7f2y4IGv5d4PhoNxFI3Fw
H47fxf5XgV3V/f8bnHNvn9M/UXL0/ojEwn0xWb7jXf5LM1jGBXn4RDO/CIaP
dOnQvHsDauV5OhuJ/xYKHkEJ/gnK6gGdv0oAAA==

-->

</rfc>

