<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Structured Headers for HTTP</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="../Tools/bower_components/bootstrap/dist/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul ul {
        list-style: none;
      }
      #sidebar {
        position: fixed;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Specifying Structured Headers" href="#rfc.section.2"><link rel="Chapter" title="3 Parsing Requirements for Textual Headers" href="#rfc.section.3"><link rel="Chapter" title="4 Structured Header Data Types" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.creator" content="Kamp, P-H."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-structured-headers-00"><meta name="dcterms.issued" content="2017-10-30"><meta name="dcterms.abstract" content="This document describes Structured Headers, a way of simplifying HTTP header field definition and parsing. It is intended for use by new HTTP header fields."><meta name="description" content="This document describes Structured Headers, a way of simplifying HTTP header field definition and parsing. It is intended for use by new HTTP header fields."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">draft-nottingham-structured-headers-00</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#specify">Specifying Structured Headers</a></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#text">Parsing Requirements for Textual Headers</a></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Structured Header Data Types</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#number">Numbers</a><ul><li><a href="#rfc.section.4.1.1">4.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-numbers-from-textual-headers">Parsing Numbers from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#string">Strings</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-a-string-from-textual-headers">Parsing a String from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.3">4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#label">Labels</a><ul><li><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-a-label-from-textual-headers">Parsing a Label from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.4">4.4.</a>&nbsp;&nbsp;&nbsp;<a href="#param">Parameterised Labels</a><ul><li><a href="#rfc.section.4.4.1">4.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-a-parameterised-label-from-textual-headers">Parsing a Parameterised Label from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.5">4.5.</a>&nbsp;&nbsp;&nbsp;<a href="#binary">Binary Content</a><ul><li><a href="#rfc.section.4.5.1">4.5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-binary-content-from-textual-headers">Parsing Binary Content from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.6">4.6.</a>&nbsp;&nbsp;&nbsp;<a href="#item">Items</a><ul><li><a href="#rfc.section.4.6.1">4.6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-an-item-from-textual-headers">Parsing an Item from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.7">4.7.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionary">Dictionaries</a><ul><li><a href="#rfc.section.4.7.1">4.7.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-a-dictionary-from-textual-headers">Parsing a Dictionary from Textual Headers</a></li></ul></li><li><a href="#rfc.section.4.8">4.8.</a>&nbsp;&nbsp;&nbsp;<a href="#list">Lists</a><ul><li><a href="#rfc.section.4.8.1">4.8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#parsing-a-list-from-textual-headers">Parsing a List from Textual Headers</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Fastly</td></tr><tr><td class="text-left">Intended status: Informational</td><td class="text-right">P-H. Kamp</td></tr><tr><td class="text-left">Expires: May 3, 2018</td><td class="text-right">The Varnish Cache Project</td></tr><tr><td class="text-left"></td><td class="text-right">October 30, 2017</td></tr></tbody></table><div id="rfc.title"><h1>Structured Headers for HTTP</h1><div class="filename">draft-nottingham-structured-headers-00</div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This document describes Structured Headers, a way of simplifying HTTP header field definition and parsing. It is intended for use by new HTTP header fields.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/structured-headers">https://github.com/mnot/I-D/labels/structured-headers</a>.</p></div><div id="rfc.note.1.p.3"><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/structured-headers/">https://mnot.github.io/I-D/structured-headers/</a>.</p></div><div id="rfc.note.1.p.4"><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/structured-headers">https://github.com/mnot/I-D/commits/gh-pages/structured-headers</a>.</p></div><div id="rfc.note.1.p.5"><p>See also the draft’s current status in the IETF datatracker, at <a href="https://datatracker.ietf.org/doc/draft-nottingham-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-structured-headers/</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on May 3, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 8.3.1, there are many decisions – and pitfalls – for a prospective HTTP header field author.</p></div><div id="rfc.section.1.p.2"><p>Likewise, bespoke parsers often need to be written for specific HTTP headers, because each has slightly different handling of what looks like common syntax.</p></div><div id="rfc.section.1.p.3"><p>This document introduces structured HTTP header field values (hereafter, Structured Headers) to address these problems. Structured Headers define a generic, abstract model for data, along with a concrete serialisation for expressing that model in textual HTTP headers, as used by HTTP/1 <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> and HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.1.p.4"><p>HTTP headers that are defined as Structured Headers use the types defined in this specification to define their syntax and basic handling rules, thereby simplifying both their definition and parsing.</p></div><div id="rfc.section.1.p.5"><p>Additionally, future versions of HTTP can define alternative serialisations of the abstract model of Structured Headers, allowing headers that use it to be transmitted more efficiently without being redefined.</p></div><div id="rfc.section.1.p.6"><p>Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.</p></div><div id="rfc.section.1.p.7"><p>To specify a header field that uses Structured Headers, see <a href="#specify" title="Specifying Structured Headers">Section&nbsp;2</a>.</p></div><div id="rfc.section.1.p.8"><p><a href="#types" title="Structured Header Data Types">Section&nbsp;4</a> defines a number of abstract data types that can be used in Structured Headers, of which only three are allowed at the “top” level: lists, dictionaries, or items.</p></div><div id="rfc.section.1.p.9"><p>Those abstract types can be serialised into textual headers – such as those used in HTTP/1 and HTTP/2 – using the algorithms described in <a href="#text" title="Parsing Requirements for Textual Headers">Section&nbsp;3</a>.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.1.p.2"><p>This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>, including the DIGIT, ALPHA and DQUOTE rules from that document. It also includes the OWS rule from <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div></section></section><section id="specify"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#specify">Specifying Structured Headers</a></h2><div id="rfc.section.2.p.1"><p>HTTP headers that use Structured Headers need to be defined to do so explicitly; recipients and generators need to know that the requirements of this document are in effect. The simplest way to do that is by referencing this document in its definition.</p></div><div id="rfc.section.2.p.2"><p>The field’s definition will also need to specify the field-value’s allowed syntax, in terms of the types described in <a href="#types" title="Structured Header Data Types">Section&nbsp;4</a>, along with their associated semantics.</p></div><div id="rfc.section.2.p.3"><p>Field definitions MUST NOT relax or otherwise modify the requirements of this specification; doing so would preclude handling by generic software.</p></div><div id="rfc.section.2.p.4"><p>However, field definitions are encouraged to clearly state additional constraints upon the syntax, as well as the consequences when those constraints are violated.</p></div><div id="rfc.section.2.p.5" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.1"><pre>
# FooExample Header

The FooExample HTTP header field conveys a list of numbers about how
much Foo the sender has.

FooExample is a Structured header [RFCxxxx]. Its value MUST be a
dictionary ([RFCxxxx], Section Y.Y).

The dictionary MUST contain:

* A member whose key is "foo", and whose value is an integer
  ([RFCxxxx], Section Y.Y), indicating the number of foos in
  the message.
* A member whose key is "bar", and whose value is a string
  ([RFCxxxx], Section Y.Y), conveying the characteristic bar-ness
  of the message.

If the parsed header field does not contain both, it MUST be ignored.
</pre></div><div id="rfc.section.2.p.6"><p>Note that empty header field values are not allowed by the syntax, and therefore will be considered errors.</p></div></section><section id="text"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#text">Parsing Requirements for Textual Headers</a></h2><div id="rfc.section.3.p.1"><p>When a receiving implementation parses textual HTTP header fields (e.g., in HTTP/1 or HTTP/2) that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</p></div><div id="rfc.section.3.p.2"><p>Given an ASCII string input_string that represents the chosen header’s field-value, return the parsed header value. Note that input_string may incorporate multiple header lines combined into one comma-separated field-value, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.2.</p></div><div id="rfc.section.3.p.3"><ol><li>Discard any OWS from the beginning of input_string.</li><li>If the field-value is defined to be a dictionary, return the result of Parsing a Dictionary from Textual headers (<a href="#dictionary" title="Dictionaries">Section&nbsp;4.7</a>).</li><li>If the field-value is defined to be a list, return the result of Parsing a List from Textual Headers (<a href="#list" title="Lists">Section&nbsp;4.8</a>).</li><li>If the field-value is defined to be a parameterised label, return the result of Parsing a Parameterised Label from Textual headers (<a href="#param" title="Parameterised Labels">Section&nbsp;4.4</a>).</li><li>Otherwise, return the result of Parsing an Item from Textual Headers (<a href="#item" title="Items">Section&nbsp;4.6</a>).</li></ol></div><div id="rfc.section.3.p.4"><p>Note that in the case of lists and dictionaries, this has the effect of combining multiple instances of the header field into one. However, for singular items and parameterised labels, it has the effect of selecting the first value and ignoring any subsequent instances of the field, as well as extraneous text afterwards.</p></div><div id="rfc.section.3.p.5"><p>Additionally, note that the effect of the parsing algorithms as specified is generally intolerant of syntax errors; if one is encountered, the typical response is to throw an error, thereby discarding the entire header field value. This includes any non-ASCII characters in input_string.</p></div></section><section id="types"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#types">Structured Header Data Types</a></h2><div id="rfc.section.4.p.1"><p>This section defines the abstract value types that can be composed into Structured Headers, along with the textual HTTP serialisations of them.</p></div><section id="number"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#number">Numbers</a></h3><div id="rfc.section.4.1.p.1"><p>Abstractly, numbers are integers with an optional fractional part. They have a maximum of fifteen digits available to be used in one or both of the parts, as reflected in the ABNF below; this allows them to be stored as IEEE 754 double precision numbers (binary64) (<a href="#IEEE754"><cite title="IEEE Standard for Floating-Point Arithmetic">[IEEE754]</cite></a>).</p></div><div id="rfc.section.4.1.p.2"><p>The textual HTTP serialisation of numbers allows a maximum of fifteen digits between the integer and fractional part, along with an optional “-“ indicating negative numbers.</p></div><div id="rfc.figure.u.2"><pre class="inline">
number   = ["-"] ( "." 1*15DIGIT /
             DIGIT "." 1*14DIGIT /
            2DIGIT "." 1*13DIGIT /
            3DIGIT "." 1*12DIGIT /
            4DIGIT "." 1*11DIGIT /
            5DIGIT "." 1*10DIGIT /
            6DIGIT "." 1*9DIGIT /
            7DIGIT "." 1*8DIGIT /
            8DIGIT "." 1*7DIGIT /
            9DIGIT "." 1*6DIGIT /
           10DIGIT "." 1*5DIGIT /
           11DIGIT "." 1*4DIGIT /
           12DIGIT "." 1*3DIGIT /
           13DIGIT "." 1*2DIGIT /
           14DIGIT "." 1DIGIT /
           15DIGIT )

integer  = ["-"] 1*15DIGIT
unsigned = 1*15DIGIT
</pre></div><div id="rfc.section.4.1.p.3"><p>integer and unsigned are defined as conveniences to specification authors; if their use is specified and their ABNF is not matched, a parser MUST consider it to be invalid.</p></div><div id="rfc.section.4.1.p.4" class="avoidbreakafter"><p>For example, a header whose value is defined as a number could look like:</p></div><div id="rfc.figure.u.3"><pre>
ExampleNumberHeader: 4.5
</pre></div><section id="parsing-numbers-from-textual-headers"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a>&nbsp;<a href="#parsing-numbers-from-textual-headers">Parsing Numbers from Textual Headers</a></h4><div id="rfc.section.4.1.1.p.1"><p>TBD</p></div></section></section><section id="string"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a href="#string">Strings</a></h3><div id="rfc.section.4.2.p.1"><p>Abstractly, strings are ASCII strings <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a>, excluding control characters (i.e., the range 0x20 to 0x7E). Note that this excludes tabs, newlines and carriage returns. They may be at most 1024 characters long.</p></div><div id="rfc.section.4.2.p.2"><p>The textual HTTP serialisation of strings uses a backslash (“") to escape double quotes and backslashes in strings.</p></div><div id="rfc.figure.u.4"><pre class="inline">
string    = DQUOTE 1*1024(char) DQUOTE
char      = unescaped / escape ( DQUOTE / "\" )
unescaped = %x20-21 / %x23-5B / %x5D-7E
escape    = "\"
</pre></div><div id="rfc.section.4.2.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a string could look like:</p></div><div id="rfc.figure.u.5"><pre>
ExampleStringHeader: "hello world"
</pre></div><div id="rfc.section.4.2.p.4"><p>Note that strings only use DQUOTE as a delimiter; single quotes do not delimit strings. Furthermore, only DQUOTE and “" can be escaped; other sequences MUST generate an error.</p></div><div id="rfc.section.4.2.p.5"><p>Unicode is not directly supported in Structured Headers, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.</p></div><div id="rfc.section.4.2.p.6"><p>When it is necessary for a field value to convey non-ASCII string content, binary content (<a href="#binary" title="Binary Content">Section&nbsp;4.5</a>) SHOULD be specified, along with a character encoding (most likely, UTF-8).</p></div><section id="parsing-a-string-from-textual-headers"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;<a href="#parsing-a-string-from-textual-headers">Parsing a String from Textual Headers</a></h4><div id="rfc.section.4.2.1.p.1"><p>Given an ASCII string input_string, return an unquoted string. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.1.p.2"><ol><li>Let output_string be an empty string.</li><li>If the first character of input_string is not DQUOTE, throw an error.</li><li>Discard the first character of input_string.</li><li>If input_string contains more than 1025 characters, throw an error.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is a backslash (“\”): <ol><li>If input_string is now empty, throw an error.</li><li>Else: <ol><li>Let next_char be the result of removing the first character of input_string.</li><li>If next_char is not DQUOTE or “\”, throw an error.</li><li>Append next_char to output_string.</li></ol></li></ol></li><li>Else, if char is DQUOTE, remove the first character of input_string and return output_string.</li><li>Else, append char to output_string.</li></ol></li><li>Otherwise, throw an error.</li></ol></div></section></section><section id="label"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a>&nbsp;<a href="#label">Labels</a></h3><div id="rfc.section.4.3.p.1"><p>Labels are short (up to 256 characters) textual identifiers; their abstract model is identical to their expression in the textual HTTP serialisation.</p></div><div id="rfc.figure.u.6"><pre class="inline">
label = lcalpha *255( lcalpha / DIGIT / "_" / "-"/ "*" / "/" )
lcalpha = %x61-7A ; a-z
</pre></div><div id="rfc.section.4.3.p.2"><p>Note that labels can only contain lowercase letters.</p></div><div id="rfc.section.4.3.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a label could look like:</p></div><div id="rfc.figure.u.7"><pre>
ExampleLabelHeader: foo/bar
</pre></div><section id="parsing-a-label-from-textual-headers"><h4 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;<a href="#parsing-a-label-from-textual-headers">Parsing a Label from Textual Headers</a></h4><div id="rfc.section.4.3.1.p.1"><p>Given an ASCII string input_string, return a label. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.3.1.p.2"><ol><li>If input_string contains more than 256 characters, throw an error.</li><li>If the first character of input_string is not lcalpha, throw an error.</li><li>Let output_string be an empty string.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is not one of lcalpha, DIGIT, “_”, “-“, “*” or “/”: <ol><li>Prepend char to input_string.</li><li>Return output_string.</li></ol></li><li>Append char to output_string.</li></ol></li><li>Return output_string.</li></ol></div></section></section><section id="param"><h3 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a>&nbsp;<a href="#param">Parameterised Labels</a></h3><div id="rfc.section.4.4.p.1"><p>Parameterised Labels are labels (<a href="#label" title="Labels">Section&nbsp;4.3</a>) with up to 256 parameters; each parameter has a label and an optional value that is an item (<a href="#item" title="Items">Section&nbsp;4.6</a>). Ordering between parameters is not significant, and duplicate parameters MUST be considered an error.</p></div><div id="rfc.section.4.4.p.2"><p>The textual HTTP serialisation uses semicolons (“;”) to delimit the parameters from each other, and equals (“=”) to delimit the parameter name from its value.</p></div><div id="rfc.figure.u.8"><pre class="inline">
parameterised = label *256( OWS ";" OWS label [ "=" item ] )
</pre></div><div id="rfc.section.4.4.p.3"><p>For example,</p></div><div id="rfc.figure.u.9"><pre>
ExampleParamHeader: abc; a=1; b=2; c
</pre></div><section id="parsing-a-parameterised-label-from-textual-headers"><h4 id="rfc.section.4.4.1"><a href="#rfc.section.4.4.1">4.4.1.</a>&nbsp;<a href="#parsing-a-parameterised-label-from-textual-headers">Parsing a Parameterised Label from Textual Headers</a></h4><div id="rfc.section.4.4.1.p.1"><p>Given an ASCII string input_string, return a label with an mapping of parameters. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.4.1.p.2"><ol><li>Let primary_label be the result of Parsing a Label from Textual Headers (<a href="#label" title="Labels">Section&nbsp;4.3</a>) from input_string.</li><li>Let parameters be an empty mapping.</li><li>In a loop: <ol><li>Consume any OWS from the beginning of input_string.</li><li>If the first character of input_string is not “;”, exit the loop.</li><li>Consume a “;” character from the beginning of input_string.</li><li>Consume any OWS from the beginning of input_string.</li><li>let param_name be the result of Parsing a Label from Textual Headers (<a href="#label" title="Labels">Section&nbsp;4.3</a>) from input_string.</li><li>If param_name is already present in parameters, throw an error.</li><li>Let param_value be a null value.</li><li>If the first character of input_string is “=”: <ol><li>Consume the “=” character at the beginning of input_string.</li><li>Let param_value be the result of Parsing an Item from Textual Headers (<a href="#item" title="Items">Section&nbsp;4.6</a>) from input_string.</li></ol></li><li>If parameters has more than 255 members, throw an error.</li><li>Add param_name to parameters with the value param_value.</li></ol></li><li>Return the tuple (primary_label, parameters).</li></ol></div></section></section><section id="binary"><h3 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a>&nbsp;<a href="#binary">Binary Content</a></h3><div id="rfc.section.4.5.p.1"><p>Arbitrary binary content up to 16K in size can be conveyed in Structured Headers.</p></div><div id="rfc.section.4.5.p.2"><p>The textual HTTP serialisation indicates their presence by a leading “*”, with the data encoded using Base 64 Encoding <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, without padding (as “=” might be confused with the use of dictionaries).</p></div><div id="rfc.figure.u.10"><pre class="inline">
binary = "*" 1*21846(base64)
base64 = ALPHA / DIGIT / "+" / "/"
</pre></div><div id="rfc.section.4.5.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as binary content could look like:</p></div><div id="rfc.figure.u.11"><pre>
ExampleBinaryHeader: *cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg
</pre></div><section id="parsing-binary-content-from-textual-headers"><h4 id="rfc.section.4.5.1"><a href="#rfc.section.4.5.1">4.5.1.</a>&nbsp;<a href="#parsing-binary-content-from-textual-headers">Parsing Binary Content from Textual Headers</a></h4><div id="rfc.section.4.5.1.p.1"><p>Given an ASCII string input_string, return binary content. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.5.1.p.2"><ol><li>If the first character of input_string is not “*”, throw an error.</li><li>Discard the first character of input_string.</li><li>Let b64_content be the result of removing content of input_string up to but not including the first character that is not in ALPHA, DIGIT, “+” or “/”.</li><li>Let binary_content be the result of Base 64 Decoding <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a> b64_content, synthesising padding if necessary. If an error is encountered, throw it.</li><li>Return binary_content.</li></ol></div></section></section><section id="item"><h3 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a>&nbsp;<a href="#item">Items</a></h3><div id="rfc.section.4.6.p.1"><p>An item is can be a number (<a href="#number" title="Numbers">Section&nbsp;4.1</a>), string (<a href="#string" title="Strings">Section&nbsp;4.2</a>), label (<a href="#label" title="Labels">Section&nbsp;4.3</a>) or binary content (<a href="#binary" title="Binary Content">Section&nbsp;4.5</a>).</p></div><div id="rfc.figure.u.12"><pre class="inline">
item = number / string / label / binary
</pre></div><section id="parsing-an-item-from-textual-headers"><h4 id="rfc.section.4.6.1"><a href="#rfc.section.4.6.1">4.6.1.</a>&nbsp;<a href="#parsing-an-item-from-textual-headers">Parsing an Item from Textual Headers</a></h4><div id="rfc.section.4.6.1.p.1"><p>Given an ASCII string input_string, return an item. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.6.1.p.2"><ol><li>Discard any OWS from the beginning of input_string.</li><li>If the first character of input_string is a “-“ or a DIGIT, process input_string as a number (<a href="#number" title="Numbers">Section&nbsp;4.1</a>) and return the result, throwing any errors encountered.</li><li>If the first character of input_string is a DQUOTE, process input_string as a string (<a href="#string" title="Strings">Section&nbsp;4.2</a>) and return the result, throwing any errors encountered.</li><li>If the first character of input_string is “*”, process input_string as binary content (<a href="#binary" title="Binary Content">Section&nbsp;4.5</a>) and return the result, throwing any errors encountered.</li><li>If the first character of input_string is an lcalpha, process input_string as a label (<a href="#label" title="Labels">Section&nbsp;4.3</a>) and return the result, throwing any errors encountered.</li><li>Otherwise, throw an error.</li></ol></div></section></section><section id="dictionary"><h3 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a>&nbsp;<a href="#dictionary">Dictionaries</a></h3><div id="rfc.section.4.7.p.1"><p>Dictionaries are unordered maps of key-value pairs, where the keys are labels (<a href="#label" title="Labels">Section&nbsp;4.3</a>) and the values are items (<a href="#item" title="Items">Section&nbsp;4.6</a>). There can be between 1 and 1024 members, and keys are required to be unique.</p></div><div id="rfc.section.4.7.p.2"><p>In the textual HTTP serialisation, keys and values are separated by “=” (without whitespace), and key/value pairs are separated by a comma with optional whitespace.</p></div><div id="rfc.figure.u.13"><pre class="inline">
dictionary = label "=" item *1023( OWS "," OWS label "=" item )
</pre></div><div id="rfc.section.4.7.p.3" class="avoidbreakafter"><p>For example, a header field whose value is defined as a dictionary could look like:</p></div><div id="rfc.figure.u.14"><pre>
ExampleDictHeader: foo=1.23, da="Applepie", en=*w4ZibGV0w6ZydGUK
</pre></div><div id="rfc.section.4.7.p.4"><p>Typically, a header field specification will define the semantics of individual keys, as well as whether their presence is required or optional. Recipients MUST ignore keys that are undefined or unknown, unless the header field’s specification specifically disallows them.</p></div><section id="parsing-a-dictionary-from-textual-headers"><h4 id="rfc.section.4.7.1"><a href="#rfc.section.4.7.1">4.7.1.</a>&nbsp;<a href="#parsing-a-dictionary-from-textual-headers">Parsing a Dictionary from Textual Headers</a></h4><div id="rfc.section.4.7.1.p.1"><p>Given an ASCII string input_string, return a mapping of (label, item). input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.7.1.p.2"><ol><li>Let dictionary be an empty mapping.</li><li>While input_string is not empty: <ol><li>Let this_key be the result of running Parse Label from Textual Headers (<a href="#label" title="Labels">Section&nbsp;4.3</a>) with input_string. If an error is encountered, throw it.</li><li>If dictionary already contains this_key, raise an error.</li><li>Consume a “=” from input_string; if none is present, raise an error.</li><li>Let this_value be the result of running Parse Item from Textual Headers (<a href="#item" title="Items">Section&nbsp;4.6</a>) with input_string. If an error is encountered, throw it.</li><li>Add key this_key with value this_value to dictionary.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return dictionary.</li><li>Consume a COMMA from input_string; if no comma is present, raise an error.</li><li>Discard any leading OWS from input_string.</li></ol></li><li>Return dictionary.</li></ol></div></section></section><section id="list"><h3 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a>&nbsp;<a href="#list">Lists</a></h3><div id="rfc.section.4.8.p.1"><p>Lists are arrays of items (<a href="#item" title="Items">Section&nbsp;4.6</a>) or parameterised labels (<a href="#param" title="Parameterised Labels">Section&nbsp;4.4</a>, with one to 1024 members.</p></div><div id="rfc.section.4.8.p.2"><p>In the textual HTTP serialisation, each member is separated by a comma and optional whitespace.</p></div><div id="rfc.figure.u.15"><pre class="inline">
list = list_member 1*1024( OWS "," OWS list_member )
list_member = item / paramterised_label
</pre></div><div id="rfc.section.4.8.p.3" class="avoidbreakafter"><p>For example, a header field whose value is defined as a list of labels could look like:</p></div><div id="rfc.figure.u.16"><pre>
ExampleLabelListHeader: foo, bar, baz_45
</pre></div><div id="rfc.section.4.8.p.4" class="avoidbreakafter"><p>and a header field whose value is defined as a list of parameterised labels could look like:</p></div><div id="rfc.figure.u.17"><pre>
ExampleParamListHeader: abc/def; g="hi";j, klm/nop
</pre></div><section id="parsing-a-list-from-textual-headers"><h4 id="rfc.section.4.8.1"><a href="#rfc.section.4.8.1">4.8.1.</a>&nbsp;<a href="#parsing-a-list-from-textual-headers">Parsing a List from Textual Headers</a></h4><div id="rfc.section.4.8.1.p.1"><p>Given an ASCII string input_string, return a list of items. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.8.1.p.2"><ol><li>Let items be an empty array.</li><li>While input_string is not empty: <ol><li>Let item be the result of running Parse Item from Textual Headers (<a href="#item" title="Items">Section&nbsp;4.6</a>) with input_string. If an error is encountered, throw it.</li><li>Append item to items.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return items.</li><li>Consume a COMMA from input_string; if no comma is present, raise an error.</li><li>Discard any leading OWS from input_string.</li></ol></li><li>Return items.</li></ol></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><p>This draft has no actions for IANA.</p></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>TBD</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC0020">[RFC0020]</dt><dd>Cerf, V., “<a href="https://tools.ietf.org/html/rfc20">ASCII format for network interchange</a>”, STD&nbsp;80, RFC&nbsp;20, <a href="http://dx.doi.org/10.17487/RFC0020">DOI&nbsp;10.17487/RFC0020</a>, October&nbsp;1969, &lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC4648">[RFC4648]</dt><dd>Josefsson, S., “<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC&nbsp;4648, <a href="http://dx.doi.org/10.17487/RFC4648">DOI&nbsp;10.17487/RFC4648</a>, October&nbsp;2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP&nbsp;14, RFC&nbsp;8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI&nbsp;10.17487/RFC8174</a>, May&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="IEEE754">[IEEE754]</dt><dd>IEEE, “<a href="http://grouper.ieee.org/groups/754/">IEEE Standard for Floating-Point Arithmetic</a>”, 2008, &lt;<a href="http://grouper.ieee.org/groups/754/">http://grouper.ieee.org/groups/754/</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address><address><b>Poul-Henning Kamp</b><br>The Varnish Cache Project<br>EMail: <a href="mailto:phk@varnish-cache.org">phk@varnish-cache.org</a></address></section></div></div></div><script src="../Tools/bower_components/jquery/dist/jquery.min.js"></script><script src="../Tools/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></body></html>