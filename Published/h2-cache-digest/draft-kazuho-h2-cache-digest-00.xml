<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfc2629xslt/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-kazuho-h2-cache-digest-00" category="info">

  <front>
    <title>Cache Digests for HTTP/2</title>

    <author initials="K." surname="Oku" fullname="Kazuho Oku">
      <organization>DeNA Co, Ltd.</organization>
      <address>
        <email>kazuhooku@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2016"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a HTTP/2 frame type to allow clients to inform the server of their
cache’s contents. Servers can then use this to inform their choices of what to push to clients.</t>



    </abstract>


    <note title="Note to Readers">


<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/h2-cache-digest">https://github.com/mnot/I-D/labels/h2-cache-digest</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/h2-cache-digest/">https://mnot.github.io/I-D/h2-cache-digest/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/h2-cache-digest">https://github.com/mnot/I-D/commits/gh-pages/h2-cache-digest</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP/2 <xref target="RFC7540"/> allows a server to “push” synthetic request/response pairs into a client’s cache
optimistically. While there is strong interest in using this facility to improve perceived Web
browsing performance, it is sometimes counterproductive because the client might already have
cached the “pushed” response.</t>

<t>When this is the case, the bandwidth used to “push” the response is effectively wasted, and
represents opportunity cost, because it could be used by other, more relevant responses. HTTP/2
allows a stream to be cancelled by a client using a RST_STREAM frame in this situation, but there
is still at least one round trip of potentially wasted capacity even then.</t>

<t>This specification defines a HTTP/2 frame type to allow clients to inform the server of their
cache’s contents using a Golumb-Rice Coded Set. Servers can then use this to inform their choices
of what to push to clients.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="the-cachedigest-frame" title="The CACHE_DIGEST Frame">

<t>The CACHE_DIGEST frame type is 0xf1. NOTE: This is an experimental value; if standardised, a
permanent value will be assigned.</t>

<figure><artwork><![CDATA[
+-----------------------------------------------+
|              Digest-Value? (\*)              ...
+-----------------------------------------------+
]]></artwork></figure>

<t>The CACHE_DIGEST frame payload has the following fields:</t>

<t><list style="symbols">
  <t><spanx style="strong">Digest-Value</spanx>: A sequence of octets containing the digest as computed in <xref target="computing"/>.</t>
</list></t>

<t>The CACHE_DIGEST frame defines the following flags:</t>

<t><list style="symbols">
  <t><spanx style="strong">RESET</spanx> (0x1): When set, indicates that any and all cache digests for the applicable origin held by the recipient MUST be considered invalid.</t>
  <t><spanx style="strong">COMPLETE</spanx> (0x2): When set, indicates that the currently valid set of cache digests held by the server constitutes a complete representation of the cache’s state regarding that origin, for the type of cached response indicated by the <spanx style="verb">STALE</spanx> flag.</t>
  <t><spanx style="strong">VALIDATORS</spanx> (0x4): When set, indicates that the <spanx style="verb">validators</spanx> boolean in <xref target="computing"/> is true.</t>
  <t><spanx style="strong">STALE</spanx> (0x8): When set, indicates that all cached responses represented in the digest-value are stale <xref target="RFC7234"/> at the point in them that the digest was generated; otherwise, all are fresh.</t>
</list></t>

<section anchor="client-behavior" title="Client Behavior">

<t>A CACHE_DIGEST frame can be sent from a client to a server on any stream in the “open” state, and
conveys a digest of the contents of the client’s cache for associated stream.</t>

<t>In typical use, a client will send one or more CACHE_DIGESTs immediately after the first request on
a connection for a given origin, on the same stream, because there is usually a short period of
inactivity then, and servers can benefit most when they understand the state of the cache before
they begin pushing associated assets (e.g., CSS, JavaScript and images). Clients MAY send
CACHE_DIGEST at other times.</t>

<t>If the cache’s state is cleared, lost, or the client otherwise wishes the server to stop using
previously sent CACHE_DIGESTs, it can send a CACHE_DIGEST with the RESET flag set.</t>

<t>When generating CACHE_DIGEST, a client MUST NOT include cached responses whose URLs do not share
origins <xref target="RFC6454"/> with the request of the stream that the frame is sent upon.</t>

<t>CACHE_DIGEST allows the client to indicate whether the set of URLs used to compute the digest
represent fresh or stale stored responses, using the STALE flag. Clients MAY decide whether to only
sent CACHE_DIGEST frames representing their fresh stored responses, their stale stored responses,
or both.</t>

<t>Clients can choose to only send a subset of the suitable stored responses of each type (fresh or
stale). However, when the CACHE_DIGEST frames sent represent the complete set of stored responses
of a given type, the last such frame SHOULD have a COMPLETE flag set, to indicate to the server
that it has all relevant state of that type. Note that for the purposes of COMPLETE, responses
cached since the beginning of the connection or the last RESET flag on a CACHE_DIGEST frame need
not be included.</t>

<t>CACHE_DIGEST can be computed to include cached responses’ ETags, as indicated by the VALIDATORS
flag. This information can be used by servers to decide what kinds of responses to push to clients;
for example, a stale response that hasn’t changed could be refreshed with a 304 (Not Modified)
response; one that has changed can be replaced with a 200 (OK) response, whether the cached
response was fresh or stale.</t>

<t>CACHE_DIGEST has no defined meaning when sent from servers, and SHOULD be ignored by clients.</t>

<section anchor="computing" title="Computing the Digest-Value">

<t>Given the following inputs:</t>

<t><list style="symbols">
  <t><spanx style="verb">validators</spanx>, a boolean indicating whether validators (<xref target="RFC7232"/>) are to be included in the digest;</t>
  <t><spanx style="verb">URLs'</spanx>, an array of (string <spanx style="verb">URL</spanx>, string <spanx style="verb">ETag</spanx>) tuples, each corresponding to the Effective Request URI (<xref target="RFC7230"/>, Section 5.5) of a cached response <xref target="RFC7234"/> and its entity-tag <xref target="RFC7232"/> (if <spanx style="verb">validators</spanx> is true and if the ETag is available; otherwise, null);</t>
  <t><spanx style="verb">P</spanx>, an integer that MUST be a power of 2 smaller than 2**32, that indicates the probability of a false positive that is acceptable, expressed as <spanx style="verb">1/P</spanx>.</t>
</list></t>

<t><spanx style="verb">digest-value</spanx> can be computed using the following algorithm:</t>

<t><list style="numbers">
  <t>Let N be the count of <spanx style="verb">URLs</spanx>’ members, rounded to the nearest power of 2 smaller than 2**32.</t>
  <t>Let <spanx style="verb">hash-values</spanx> be an empty array of integers.</t>
  <t>Append 0 to <spanx style="verb">hash-values</spanx>.</t>
  <t>For each (<spanx style="verb">URL</spanx>, <spanx style="verb">ETag</spanx>) in <spanx style="verb">URLs</spanx>, compute a hash value (<xref target="hash"/>) and append the result to <spanx style="verb">hash-values</spanx>.</t>
  <t>Sort <spanx style="verb">hash-values</spanx> in ascending order.</t>
  <t>Let <spanx style="verb">digest-value</spanx> be an empty array of bits.</t>
  <t>Write log base 2 of <spanx style="verb">N</spanx> to <spanx style="verb">digest-value</spanx> using 5 bits.</t>
  <t>Write log base 2 of <spanx style="verb">P</spanx> to <spanx style="verb">digest-value</spanx> using 5 bits.</t>
  <t>For each <spanx style="verb">V</spanx> in <spanx style="verb">hash-values</spanx>:
  <list style="numbers">
      <t>Let <spanx style="verb">W</spanx> be the value following <spanx style="verb">V</spanx> in <spanx style="verb">hash-values</spanx>.</t>
      <t>If <spanx style="verb">W</spanx> and <spanx style="verb">V</spanx> are equal, continue to the next <spanx style="verb">V</spanx>.</t>
      <t>Let <spanx style="verb">D</spanx> be the result of <spanx style="verb">W - V - 1</spanx>.</t>
      <t>Let <spanx style="verb">Q</spanx> be the integer result of <spanx style="verb">D / P</spanx>.</t>
      <t>Let <spanx style="verb">R</spanx> be the result of <spanx style="verb">D modulo P</spanx>.</t>
      <t>Write <spanx style="verb">Q</spanx> ‘0’ bits to <spanx style="verb">digest-value</spanx>.</t>
      <t>Write 1 ‘1’ bit to <spanx style="verb">digest-value</spanx>.</t>
      <t>Write <spanx style="verb">R</spanx> to <spanx style="verb">digest-value</spanx> as binary, using log2(<spanx style="verb">P</spanx>5) bits.</t>
      <t>If <spanx style="verb">V</spanx> is the second-to-last member of <spanx style="verb">hash-values</spanx>, stop iterating through <spanx style="verb">hash-values</spanx> and continue to the next step.</t>
    </list></t>
  <t>If the length of <spanx style="verb">digest-value</spanx> is not a multiple of 8, pad it with 0s until it is.</t>
</list></t>

</section>
<section anchor="hash" title="Computing a Hash Value">

<t>Given:</t>

<t><list style="symbols">
  <t><spanx style="verb">URL</spanx>, an array of characters</t>
  <t><spanx style="verb">ETag</spanx>, an array of characters</t>
  <t><spanx style="verb">validators</spanx>, a boolean</t>
  <t><spanx style="verb">N</spanx>, an integer</t>
  <t><spanx style="verb">P</spanx>, an integer</t>
</list></t>

<t><spanx style="verb">hash-value</spanx> can be computed using the following algorithm:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">key</spanx> be <spanx style="verb">URL</spanx> converted to an ASCII string by percent-encoding as appropriate <xref target="RFC3986"/>.</t>
  <t>If <spanx style="verb">validators</spanx> is true and <spanx style="verb">ETag</spanx> is not null:
  <list style="numbers">
      <t>Append <spanx style="verb">ETag</spanx> to <spanx style="verb">key</spanx> as an ASCII string, including both the <spanx style="verb">weak</spanx> indicator (if present) and double quotes, as per <xref target="RFC7232"/> Section 2.3.</t>
    </list></t>
  <t>Let <spanx style="verb">hash-value</spanx> be the SHA-256 message digest <xref target="RFC6234"/> of <spanx style="verb">key</spanx>, expressed as an integer.</t>
  <t>Truncate <spanx style="verb">hash-value</spanx> to log2( <spanx style="verb">N</spanx> * <spanx style="verb">P</spanx> ) bits.</t>
</list></t>

</section>
</section>
<section anchor="server-behavior" title="Server Behavior">

<t>In typical use, a server will query (as per <xref target="querying"/>) the CACHE_DIGESTs received on a given
connection to inform what it pushes to that client;</t>

<t><list style="symbols">
  <t>If a given URL has a match in a current CACHE_DIGEST with the STALE flag unset, it need not be pushed, because it is fresh in cache;</t>
  <t>If a given URL and ETag combination has a match in a current CACHE_DIGEST with the STALE flag set, the client has a stale copy in cache, and a validating response can be pushed;</t>
  <t>If a given URL has no match in any current CACHE_DIGEST, the client does not have a cached copy, and a complete response can be pushed.</t>
</list></t>

<t>Servers MAY use all CACHE_DIGESTs received for a given origin as current, as long as they do not
have the RESET flag set; a CACHE_DIGEST frame with the RESET flag set MUST clear any
previously stored CACHE_DIGESTs for its origin. Servers MUST treat an empty Digest-Value with a
RESET flag set as effectively clearing all stored digests for that origin.</t>

<t>Clients are not likely to send updates to CACHE_DIGEST over the lifetime of a connection; it is
expected that servers will separately track what cacheable responses have been sent previously on
the same connection, using that knowledge in conjunction with that provided by CACHE_DIGEST.</t>

<section anchor="querying" title="Querying the Digest for a Value">

<t>Given:</t>

<t><list style="symbols">
  <t><spanx style="verb">digest-value</spanx>, an array of bits</t>
  <t><spanx style="verb">URL</spanx>, an array of characters</t>
  <t><spanx style="verb">ETag</spanx>, an array of characters</t>
  <t><spanx style="verb">validators</spanx>, a boolean</t>
</list></t>

<t>we can determine whether there is a match in the digest using the following algorithm:</t>

<t><list style="numbers">
  <t>Read the first 5 bits of <spanx style="verb">digest-value</spanx> as an integer; let <spanx style="verb">N</spanx> be two raised to the power of that value.</t>
  <t>Read the next 5 bits of <spanx style="verb">digest-value</spanx> as an integer; let <spanx style="verb">P</spanx> be two raised to the power of that value.</t>
  <t>Let <spanx style="verb">hash-value</spanx> be the result of computing a hash value (<xref target="hash"/>).</t>
  <t>Let <spanx style="verb">C</spanx> be -1.</t>
  <t>Read ‘0’ bits from <spanx style="verb">digest-value</spanx> until a ‘1’ bit is found; let <spanx style="verb">Q</spanx> bit the number of ‘0’ bits. Discard the ‘1’.</t>
  <t>Read log2(<spanx style="verb">P</spanx>) bits from <spanx style="verb">digest-value</spanx> after the ‘1’ as an integer; let <spanx style="verb">R</spanx> be its value.</t>
  <t>Let <spanx style="verb">D</spanx> be <spanx style="verb">Q</spanx> * <spanx style="verb">P</spanx> + <spanx style="verb">R</spanx>.</t>
  <t>Increment <spanx style="verb">C</spanx> by <spanx style="verb">D</spanx> + 1.</t>
  <t>If <spanx style="verb">C</spanx> is equal to <spanx style="verb">hash-value</spanx>, return ‘true’.</t>
  <t>Otherwise, return to step 5 and continue processing; if no match is found before <spanx style="verb">digest-value</spanx> is exhausted, return ‘false’.</t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This draft currently has no requirements for IANA. If the CACHE_DIGEST frame is standardised, it
will need to be assigned a frame type.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>The contents of a User Agent’s cache can be used to re-identify or “fingerprint” the user over
time, even when other identifiers (e.g., Cookies <xref target="RFC6265"/>) are cleared.</t>

<t>CACHE_DIGEST allows such cache-based fingerprinting to become passive, since it allows the server
to discover the state of the client’s cache without any visible change in server behaviour.</t>

<t>As a result, clients MUST mitigate for this threat when the user attempts to remove identifiers
(e.g., “clearing cookies”). This could be achieved in a number of ways; for example: by clearing
the cache, by changing one or both of N and P, or by adding new, synthetic entries to the digest to
change its contents.</t>

<t>TODO: discuss how effective the suggested mitigations actually would be.</t>

<t>Additionally, User Agents SHOULD NOT send CACHE_DIGEST when in “privacy mode.”</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC3986' target='http://www.rfc-editor.org/info/rfc3986'>
<front>
<title>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='T. Berners-Lee'><organization /></author>
<author initials='R.' surname='Fielding' fullname='R. Fielding'><organization /></author>
<author initials='L.' surname='Masinter' fullname='L. Masinter'><organization /></author>
<date year='2005' month='January' />
<abstract><t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='66'/>
<seriesInfo name='RFC' value='3986'/>
<seriesInfo name='DOI' value='10.17487/RFC3986'/>
</reference>



<reference  anchor='RFC6234' target='http://www.rfc-editor.org/info/rfc6234'>
<front>
<title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake 3rd'><organization /></author>
<author initials='T.' surname='Hansen' fullname='T. Hansen'><organization /></author>
<date year='2011' month='May' />
<abstract><t>Federal Information Processing Standard, FIPS</t></abstract>
</front>
<seriesInfo name='RFC' value='6234'/>
<seriesInfo name='DOI' value='10.17487/RFC6234'/>
</reference>



<reference  anchor='RFC6454' target='http://www.rfc-editor.org/info/rfc6454'>
<front>
<title>The Web Origin Concept</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='December' />
<abstract><t>This document defines the concept of an &quot;origin&quot;, which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named &quot;Origin&quot;, that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6454'/>
<seriesInfo name='DOI' value='10.17487/RFC6454'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC7232' target='http://www.rfc-editor.org/info/rfc7232'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.</t></abstract>
</front>
<seriesInfo name='RFC' value='7232'/>
<seriesInfo name='DOI' value='10.17487/RFC7232'/>
</reference>



<reference  anchor='RFC7234' target='http://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC6265' target='http://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>


<section anchor="acknowledgements" title="Acknowledgements">

<t>Thanks to Adam Langley and Giovanni Bajo for their explorations of Golumb-coded sets. In
particular, see
<eref target="http://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters">http://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters</eref>, which
refers to sample code.</t>

<t>Thanks to Stefan Eissing for his suggestions.</t>

</section>


  </back>
</rfc>

