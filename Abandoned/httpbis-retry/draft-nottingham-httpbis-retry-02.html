<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Retrying HTTP Requests</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Background" href="#rfc.section.2"><link rel="Chapter" title="3 Discussion" href="#rfc.section.3"><link rel="Chapter" title="4 Possible Areas of Work" href="#rfc.section.4"><link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Acknowledgements" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Appendix" title="A When Clients Retry" href="#rfc.section.A"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-httpbis-retry-02"><meta name="dcterms.issued" content="2017-02-02"><meta name="dcterms.abstract" content="HTTP allows requests to be automatically retried under certain circumstances. This draft explores how this is implemented, requirements for similar functionality from other parts of the stack, and potential future improvements."><meta name="description" content="HTTP allows requests to be automatically retried under certain circumstances. This draft explores how this is implemented, requirements for similar functionality from other parts of the stack, and potential future improvements."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc..toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#background">Background</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#retry_replay">Retries and Replays: A Taxonomy of Repetition</a></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#spec">What the Spec Says: Automatic Retries</a></li><li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#spec-replay">What the Specs Say: Replay</a><ul><li><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#tcp-fast-open">TCP Fast Open</a></li><li><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#tls-13">TLS 1.3</a></li><li><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#quic">QUIC</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#discussion">Discussion</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#auto_retry">Automatic Retries In Practice</a></li><li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#replay">Replays Are Different</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#work">Possible Areas of Work</a><ul><li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#update">Updating HTTP’s Requirements for Retries</a></li><li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#detect">Protocol Extensions</a></li><li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#feedback">Feedback to Transport 0RTT Efforts</a></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#current">When Clients Retry</a><ul><li><a href="#rfc.section.A.1">A.1</a>&nbsp;&nbsp;&nbsp;<a href="#squid">Squid</a></li><li><a href="#rfc.section.A.2">A.2</a>&nbsp;&nbsp;&nbsp;<a href="#traffic-server">Traffic Server</a></li><li><a href="#rfc.section.A.3">A.3</a>&nbsp;&nbsp;&nbsp;<a href="#firefox">Firefox</a></li><li><a href="#rfc.section.A.4">A.4</a>&nbsp;&nbsp;&nbsp;<a href="#chromium">Chromium</a></li><li><a href="#rfc.section.A.5">A.5</a>&nbsp;&nbsp;&nbsp;<a href="#curl">Curl</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">February 2, 2017</td></tr><tr><td class="text-left">Intended status: Informational</td><td class="text-right"></td></tr><tr><td class="text-left">Expires: August 6, 2017</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Retrying HTTP Requests</h1><div class="filename">draft-nottingham-httpbis-retry-02</div></div></header><hr><h2 id="rfc..abstract"><a href="#rfc..abstract">Abstract</a></h2><div class="lead"><p>HTTP allows requests to be automatically retried under certain circumstances. This draft explores how this is implemented, requirements for similar functionality from other parts of the stack, and potential future improvements.</p></div><section id="rfc.note.1"><h2><a href="#rfc.note.1">Note to Readers</a></h2><p>This draft is not intended to be published as an RFC.</p><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/httpbis-retry">https://github.com/mnot/I-D/labels/httpbis-retry</a>.</p><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/httpbis-retry/">https://mnot.github.io/I-D/httpbis-retry/</a>.</p><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/httpbis-retry">https://github.com/mnot/I-D/commits/gh-pages/httpbis-retry</a>.</p></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on August 6, 2017.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>One of the benefits of HTTP’s well-defined method semantics is that they allow failed requests to be retried, under certain circumstances.</p></div><div id="rfc.section.1.p.2" class="avoidbreakafter"><p>However, interest in extending, redefining or just clarifying HTTP’s retry semantics is increasing, for a number of reasons:</p></div><div id="rfc.section.1.p.3"><ul><li>Since HTTP/1.1’s requirements were written, there has been a substantial amount of experience deploying and using HTTP, leading implementations to refine their behaviour, often diverging from the specification.</li><li>Likewise, changes such as HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> might change the underlying assumptions that these requirements were based upon.</li><li>Emerging lower-layer developments such as TCP Fast Open <a href="#RFC7413"><cite title="TCP Fast Open">[RFC7413]</cite></a>, TLS/1.3 <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a> and QUIC <a href="#I-D.ietf-quic-transport"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[I-D.ietf-quic-transport]</cite></a> introduce the possibility of replayed requests in the beginning of a connection, thanks to Zero Round Trip (0RT) modes. In some ways, these are similar to retries – but not completely.</li><li>Applications sometimes want requests to be retried by infrastructure, but can’t easily express them in an idempotent request (such as GET).</li></ul></div><div id="rfc.section.1.p.4"><p>This draft gives some background in <a href="#background" title="Background">Section&nbsp;2</a>, discusses aspects of these issues in <a href="#discussion" title="Discussion">Section&nbsp;3</a>, suggesting possible areas of work in <a href="#work" title="Possible Areas of Work">Section&nbsp;4</a>, and cataloguing current implementation behaviours in <a href="#current" title="When Clients Retry">Appendix&nbsp;A</a>.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><section id="background"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#background">Background</a></h2><section id="retry_replay"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#retry_replay">Retries and Replays: A Taxonomy of Repetition</a></h3><div id="rfc.section.2.1.p.1" class="avoidbreakafter"><p>In HTTP, there are three similar but separate phenomena that deserve consideration for the purposes of this document:</p></div><div id="rfc.section.2.1.p.2"><ol><li><strong>User Retries</strong> happen when a user initiates an action that results in a duplicate HTTP request message being emitted. For example, a user retry might occur when a “reload” button is pressed, a URL is typed in again, “return” is pressed in the URL bar again, or a navigation link or form button is pressed twice while still on screen.</li><li><strong>Automatic Retries</strong> happen when an HTTP client implementation resends a previous request message without user intervention or initiation. This might happen when a GET request fails to return a complete response, or when a connection drops before the request is sent. Note that automatic retries can (and are) performed both by user agents and intermediary clients.</li><li><strong>Replays</strong> happen when the underlying transport units (e.g., TCP packets, QUIC frames) containing a HTTP request message are re-sent on the network <strong>and</strong> appear to be separate requests to the downstream server, either automatically as part of transport protocol operation, or by an attacker. The upstream HTTP client might not have any indication that a replay has occurred.</li></ol></div><div id="rfc.section.2.1.p.3"><p>Note that retries initiated by code shipped to the client by the server (e.g., in JavaScript) occupy a grey area here. Because they are not initiated by the generic HTTP client implementation itself, we will consider them user retries for the time being.</p></div><div id="rfc.section.2.1.p.4"><p>Also, this document doesn’t include transport layer loss recovery (e.g., TCP retransmission). This is distinguished from replays because the transport automatically suppresses duplicates.</p></div></section><section id="spec"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a href="#spec">What the Spec Says: Automatic Retries</a></h3><div id="rfc.section.2.2.p.1" class="avoidbreakafter"><p><a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 6.3.1 allows HTTP requests to be retried in certain circumstances:</p></div><div id="rfc.section.2.2.p.2"><ul class="empty"><li>When an inbound connection is closed prematurely, a client MAY open a new connection and automatically retransmit an aborted sequence of requests if all of those requests have idempotent methods (Section 4.2.2 of <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>). A proxy MUST NOT automatically retry non-idempotent requests.</li></ul></div><div id="rfc.section.2.2.p.3"><ul class="empty"><li>A user agent MUST NOT automatically retry a request with a non-idempotent method unless it has some means to know that the request semantics are actually idempotent, regardless of the method, or some means to detect that the original request was never applied. For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically. Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by checking the target resource revision(s) after a failed connection, reverting or fixing any changes that were partially applied, and then automatically retrying the requests that failed.</li></ul></div><div id="rfc.section.2.2.p.4"><ul class="empty"><li>A client SHOULD NOT automatically retry a failed automatic retry.</li></ul></div><div id="rfc.section.2.2.p.5"><p>Note that the complete list of idempotent methods is maintained in the <a href="https://www.iana.org/assignments/http-methods/http-methods.xhtml">IANA HTTP Method Registry</a>.</p></div></section><section id="spec-replay"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a href="#spec-replay">What the Specs Say: Replay</a></h3><section id="tcp-fast-open"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a href="#tcp-fast-open">TCP Fast Open</a></h4><div id="rfc.section.2.3.1.p.1" class="avoidbreakafter"><p><a href="#RFC7413"><cite title="TCP Fast Open">[RFC7413]</cite></a>, Section 6.3.1 addresses HTTP Request Replay with TCP Fast Open:</p></div><div id="rfc.section.2.3.1.p.2"><ul class="empty"><li>While TFO is motivated by Web applications, the browser should not use TFO to send requests in SYNs if those requests cannot tolerate replays. One example is POST requests without application-layer transaction protection (e.g., a unique identifier in the request header).</li></ul></div><div id="rfc.section.2.3.1.p.3"><ul class="empty"><li>On the other hand, TFO is particularly useful for GET requests. GET request replay could happen across striped TCP connections: after a server receives an HTTP request but before the ACKs of the requests reach the browser, the browser may time out and retry the same request on another (possibly new) TCP connection. This differs from a TFO replay only in that the replay is initiated by the browser, not by the TCP stack.</li></ul></div><div id="rfc.section.2.3.1.p.4" class="avoidbreakafter"><p>The same specification addresses HTTP over TLS in Section 6.3.2:</p></div><div id="rfc.section.2.3.1.p.5"><ul class="empty"><li>For Transport Layer Security (TLS) over TCP, it is safe and useful to include a TLS client_hello in the SYN packet to save one RTT in the TLS handshake. There is no concern about violating idempotency. In particular, it can be used alone with the speculative connection above.</li></ul></div></section><section id="tls-13"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;<a href="#tls-13">TLS 1.3</a></h4><div id="rfc.section.2.3.2.p.1" class="avoidbreakafter"><p><a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>, Section 2.3 explains the properties of Zero-RTT Data in TLS 1.3:</p></div><div id="rfc.section.2.3.2.p.2" class="avoidbreakafter"><ul class="empty"><li>IMPORTANT NOTE: The security properties for 0-RTT data (regardless of the cipher suite) are weaker than those for other kinds of TLS data. Specifically:</li></ul></div><div id="rfc.section.2.3.2.p.3"><ul class="empty"><li><ol><li>This data is not forward secret, because it is encrypted solely with the PSK.</li><li>There are no guarantees of non-replay between connections. Unless the server takes special measures outside those provided by TLS, the server has no guarantee that the same 0-RTT data was not transmitted on multiple 0-RTT connections (See Section 4.2.6.2 for more details). This is especially relevant if the data is authenticated either with TLS client authentication or inside the application layer protocol. However, 0-RTT data cannot be duplicated within a connection (i.e., the server will not process the same data twice for the same connection) and an attacker will not be able to make 0-RTT data appear to be 1-RTT data (because it is protected with different keys.)</li></ol></li></ul></div><div id="rfc.section.2.3.2.p.4"><p>Section 4.2.6 defines a mechanism to limit the exposure to replay.</p></div></section><section id="quic"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;<a href="#quic">QUIC</a></h4><div id="rfc.section.2.3.3.p.1" class="avoidbreakafter"><p><a href="#I-D.ietf-quic-tls"><cite title="Using Transport Layer Security (TLS) to Secure QUIC">[I-D.ietf-quic-tls]</cite></a> Section 7.2 says this about the risks of replay during the 0RTT handshake:</p></div><div id="rfc.section.2.3.3.p.2"><ul class="empty"><li>If 0-RTT keys are available, the lack of replay protection means that restrictions on their use are necessary to avoid replay attacks on the protocol.</li><li>A client MUST only use 0-RTT keys to protect data that is idempotent. A client MAY wish to apply additional restrictions on what data it sends prior to the completion of the TLS handshake. A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys.</li><li>A client that receives an indication that its 0-RTT data has been accepted by a server can send 0-RTT data until it receives all of the server’s handshake messages. A client SHOULD stop sending 0-RTT data if it receives an indication that 0-RTT data has been rejected.</li><li>A server MUST NOT use 0-RTT keys to protect packets.</li></ul></div></section></section></section><section id="discussion"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#discussion">Discussion</a></h2><section id="auto_retry"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#auto_retry">Automatic Retries In Practice</a></h3><div id="rfc.section.3.1.p.1" class="avoidbreakafter"><p>In practice, it has been observed (see <a href="#current" title="When Clients Retry">Appendix&nbsp;A</a>) that some client implementations (both user agent and intermediary) do automatically retry requests. However, they do not do so consistently, and arguably not in the spirit of the specification, unless this vague catch-all:</p></div><div id="rfc.section.3.1.p.2"><ul class="empty"><li>some means to detect that the original request was never applied</li></ul></div><div id="rfc.section.3.1.p.3"><p>is interpreted very broadly.</p></div><div id="rfc.section.3.1.p.4"><p>On the server side, it has been widely observed that content on the Web doesn’t always honour HTTP idemotency semantics, with many GET requests incurring side effects, and with some sites even requiring browsers to retry POST requests in order to properly interoperate.</p></div><div id="rfc.section.3.1.p.5"><p>Despite this situation, the Web seems to work reasonably well to date (with <a href="https://signalvnoise.com/archives2/google_web_accelerator_hey_not_so_fast_an_alert_for_web_app_designers.php">notable exceptions</a>).</p></div><div id="rfc.section.3.1.p.6"><p>The status quo, therefore, is that no Web application can read HTTP’s retry requirements as a guarantee that any given request won’t be retried, even for methods that are not idempotent. As a result, applications that care about avoiding duplicate requests need to build a way to detect not only user retries but also automatic retries into the application “above” HTTP itself.</p></div></section><section id="replay"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#replay">Replays Are Different</a></h3><div id="rfc.section.3.2.p.1"><p>TCP Fast Open <a href="#RFC7413"><cite title="TCP Fast Open">[RFC7413]</cite></a>, TLS/1.3 <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a> and QUIC <a href="#I-D.ietf-quic-transport"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[I-D.ietf-quic-transport]</cite></a> all have mechanisms to carry application data on the first packet sent by a client, to avoid the latency of connection setup.</p></div><div id="rfc.section.3.2.p.2"><p>The request(s) in this first packet might be <em>replayed</em>, either because the first packet (now carrying a HTTP request) is thought to be lost and retransmitted, or because an attacker observes the packet and sends a duplicate at some point in the future.</p></div><div id="rfc.section.3.2.p.3"><p>At first glance, it seems as if the idempotency semantics of HTTP request methods could be used to determine what requests are suitable for inclusion in the first packet of various 0RTT mechanisms being discussed (as suggested by TCP Fast Open). For example, we could disallow POST (and other non-idempotent methods) in 0RTT data.</p></div><div id="rfc.section.3.2.p.4"><p>Upon reflection, though, the observations above lead us to believe that since any request might be retried (automatically or by users), applications will still need to have a means of detecting duplicate requests, thereby preventing side effects from replays as well as retries. Thus, any HTTP request can be included in the first packet of a 0RTT, despite the risk of replay.</p></div><div id="rfc.section.3.2.p.5" class="avoidbreakafter"><p>Two types of attack specific to replayed HTTP requests need to be taken into account, however:</p></div><div id="rfc.section.3.2.p.6"><ol><li>A replay is a potential Denial of Service vector. An attacker that can replay a request many times can probe for weaknesses in retry protections, and can bring a server that needs to do any substantial processing down.</li><li>An attacker might use a replayed request to leak information about the response over time. If they can observe the encrypted payload on the wire, they can infer the size of the response (e.g., it might get bigger if the user’s bank account has more in it).</li></ol></div><div id="rfc.section.3.2.p.7"><p>The first attack cannot be mitigated by HTTP; the 0RT mechanism itself needs some transport-layer means of scoping the usability of the first packet on a connection so that it cannot be reused broadly. For example, this might be by time, or by network location.</p></div><div id="rfc.section.3.2.p.8"><p>The second attack is more difficult to mitigate; scoping the usability of the first packet helps, but does not completely prevent the attack. If the replayed request is state-changing, the application’s retry detection should kick in and prevent information leakage (since the response will likely contain an error, instead of the desired information).</p></div><div id="rfc.section.3.2.p.9"><p>If it is not (e.g., a GET), the information being targeted is vulnerable as long as both the first packet and the credentials in the request (if any) are valid.</p></div></section></section><section id="work"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#work">Possible Areas of Work</a></h2><section id="update"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a href="#update">Updating HTTP’s Requirements for Retries</a></h3><div id="rfc.section.4.1.p.1"><p>The currently language in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> about retries is vague about the conditions under which a request can be retried, leading to significant variance in implementation behaviour. For example, it’s been observed that many automated clients fail under circumstances when browsers succeed, because they do not retry in the same way.</p></div><div id="rfc.section.4.1.p.2" class="avoidbreakafter"><p>As a result, more carefully specifying the conditions under which a request can be retried would be helpful. Such work would need to take into account varying conditions, such as:</p></div><div id="rfc.section.4.1.p.3"><ul><li>Connection closes</li><li>TCP RST</li><li>Connection timeouts</li><li>Whether or not any part of the response has been received</li><li>Whether or not it is the first request on the connection</li><li>Variance due to use of HTTP/2, TLS/1.3, TCP Fast Open and QUIC.</li></ul></div><div id="rfc.section.4.1.p.4"><p>Furthermore, readers might mistake the language in RFC7230 as guaranteeing that some requests (e.g., POST) are never automatically retried; this should be clarified.</p></div></section><section id="detect"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a href="#detect">Protocol Extensions</a></h3><div id="rfc.section.4.2.p.1" class="avoidbreakafter"><p>A number of mechanisms have been mooted at various times, e.g.:</p></div><div id="rfc.section.4.2.p.2"><ul><li>Adding a header to automatically retried requests, to aid de-duplication by servers</li><li>Defining a request header to by added by intermediaries when they have received a request in a way that could have been replayed</li><li>Defining a status code to allow servers to indicate that the request needs to be sent in a way that can’t be replayed</li></ul></div></section><section id="feedback"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a href="#feedback">Feedback to Transport 0RTT Efforts</a></h3><div id="rfc.section.4.3.p.1"><p>If the observations above hold, we should disabuse any notion that HTTP method idempotency is a useful way to avoid problems with replay attacks. Instead, we should encourage development of mechanisms to mitigate the aspects of replay that are different than retries (e.g., potential for DOS attacks).</p></div></section></section><section id="security-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.5.p.1"><p>Yep.</p></div></section><section id="acknowledgements"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.6.p.1"><p>Thanks to Brad Fitzpatrick, Leif Hedstrom, Subodh Iyengar, Amos Jeffries, Patrick McManus, Matt Menke, Miroslav Ponec, Daniel Stenberg and Martin Thomson for their input and feedback.</p></div><div id="rfc.section.6.p.2"><p>Thanks also to the participants in the 2016 HTTP Workshop for their lively discussion of this topic.</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a> Normative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-quic-tls">[I-D.ietf-quic-tls]</dt><dd>Thomson, M. and (. (Unknown), “<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-01">Using Transport Layer Security (TLS) to Secure QUIC</a>”, Internet-Draft&nbsp;draft-ietf-quic-tls-01 (work in progress), January&nbsp;2017.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7413">[RFC7413]</dt><dd>Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, “<a href="https://tools.ietf.org/html/rfc7413">TCP Fast Open</a>”, RFC&nbsp;7413, <a href="http://dx.doi.org/10.17487/RFC7413">DOI&nbsp;10.17487/RFC7413</a>, December&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7413">http://www.rfc-editor.org/info/rfc7413</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a> Informative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</dt><dd>Iyengar, J. and M. Thomson, “<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-01">QUIC: A UDP-Based Multiplexed and Secure Transport</a>”, Internet-Draft&nbsp;draft-ietf-quic-transport-01 (work in progress), January&nbsp;2017.</dd><dt id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-18">The Transport Layer Security (TLS) Protocol Version 1.3</a>”, Internet-Draft&nbsp;draft-ietf-tls-tls13-18 (work in progress), October&nbsp;2016.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></section></section><section id="current"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#current">When Clients Retry</a></h2><div id="rfc.section.A.p.1"><p>In implementations, clients have been observed to retry requests in a number of circumstances.</p></div><div id="rfc.section.A.p.2"><p><em>Note: This section is intended to inform the discussion, not to be published as a standard. If you have relevant information about these or other implementations (open or closed), please get in touch.</em></p></div><section id="squid"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1</a>&nbsp;<a href="#squid">Squid</a></h3><div id="rfc.section.A.1.p.1" class="avoidbreakafter"><p>Squid is a caching proxy server that retries requests that it considers safe <strong>or</strong> idempotent, as long as there is not a request body:</p></div><div id="rfc.figure.u.1"><pre>
/// Whether we may try sending this request again after a failure.
bool
FwdState::checkRetriable()
{
    // Optimize: A compliant proxy may retry PUTs, but Squid lacks the [rather
    // complicated] code required to protect the PUT request body from being
    // nibbled during the first try. Thus, Squid cannot retry some PUTs today.
    if (request-&gt;body_pipe != NULL)
        return false;

    // RFC2616 9.1 Safe and Idempotent Methods
    return (request-&gt;method.isHttpSafe() || request-&gt;method.isIdempotent());
}
</pre></div><div id="rfc.section.A.1.p.2"><p>(<a href="http://bazaar.launchpad.net/~squid/squid/trunk/view/head:/src/FwdState.cc#L594">source</a>)</p></div><div id="rfc.section.A.1.p.3"><p>Currently, it considers GET, HEAD, OPTIONS, REPORT, PROPFIND, SEARCH and PRI to be safe, and GET, HEAD, PUT, DELETE, OPTIONS, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, UNLOCK, and PRI to be idempotent.</p></div></section><section id="traffic-server"><h3 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2</a>&nbsp;<a href="#traffic-server">Traffic Server</a></h3><div id="rfc.section.A.2.p.1"><p>Apache Traffic Server, a caching proxy server, ties retry-ability to whether the request required a “tunnel” – i.e., forwarding the request body to the next server. This is indicated by <span class="tt">request_body_start</span>, which is set when a POST tunnel is used.</p></div><div id="rfc.figure.u.2"><pre>
// bool HttpTransact::is_request_retryable
//
//   If we started a POST/PUT tunnel then we can
//    not retry failed requests
//
bool
HttpTransact::is_request_retryable(State *s)
{
  if (s-&gt;hdr_info.request_body_start == true) {
    return false;
  }

  if (s-&gt;state_machine-&gt;plugin_tunnel_type != HTTP_NO_PLUGIN_TUNNEL) {
    // API can override
    if (s-&gt;state_machine-&gt;plugin_tunnel_type == HTTP_PLUGIN_AS_SERVER &amp;&amp;
        s-&gt;api_info.retry_intercept_failures == true) {
      // This used to be an == comparison, which made no sense. Changed
      // to be an assignment, hoping the state is correct.
      s-&gt;state_machine-&gt;plugin_tunnel_type = HTTP_NO_PLUGIN_TUNNEL;
    } else {
      return false;
    }
  }

  return true;
}
</pre></div><div id="rfc.section.A.2.p.2"><p>(<a href="https://git-wip-us.apache.org/repos/asf?p=trafficserver.git;a=blob;f=proxy/http/HttpTransact.cc;h=8a1f5364d47654b118296a07a2a95284f119d84b;hb=HEAD#l6408">source</a>)</p></div><div id="rfc.section.A.2.p.3" class="avoidbreakafter"><p>When connected to an origin server, Traffic Server attempts to retry under a number of failure conditions:</p></div><div id="rfc.figure.u.3"><pre>
/////////////////////////////////////////////////////////////////////////
// Name       : handle_response_from_server
// Description: response is from the origin server
//
// Details    :
//
//   response from the origin server. one of three things can happen now.
//   if the response is bad, then we can either retry (by first downgrading
//   the request, maybe making it non-keepalive, etc.), or we can give up.
//   the latter case is handled by handle_server_connection_not_open and
//   sends an error response back to the client. if the response is good
//   handle_forward_server_connection_open is called.
//
//
// Possible Next States From Here:
//
/////////////////////////////////////////////////////////////////////////
void
HttpTransact::handle_response_from_server(State *s)
{

[...]

  switch (s-&gt;current.state) {
  case CONNECTION_ALIVE:
    DebugTxn("http_trans", "[hrfs] connection alive");
    SET_VIA_STRING(VIA_DETAIL_SERVER_CONNECT, VIA_DETAIL_SERVER_SUCCESS);
    s-&gt;current.server-&gt;clear_connect_fail();
    handle_forward_server_connection_open(s);
    break;

[...]

  case OPEN_RAW_ERROR:
  /* fall through */
  case CONNECTION_ERROR:
  /* fall through */
  case STATE_UNDEFINED:
  /* fall through */
  case INACTIVE_TIMEOUT:
    // Set to generic I/O error if not already set specifically.
    if (!s-&gt;current.server-&gt;had_connect_fail())
      s-&gt;current.server-&gt;set_connect_fail(EIO);

    if (is_server_negative_cached(s)) {
      max_connect_retries = s-&gt;txn_conf-&gt;connect_attempts_max_retries_dead_server;
    } else {
      // server not yet negative cached - use default number of retries
      max_connect_retries = s-&gt;txn_conf-&gt;connect_attempts_max_retries;
    }
    if (s-&gt;pCongestionEntry != NULL)
      max_connect_retries = s-&gt;pCongestionEntry-&gt;connect_retries();

    if (is_request_retryable(s) &amp;&amp; s-&gt;current.attempts &lt; max_connect_retries) {
</pre></div><div id="rfc.section.A.2.p.4"><p>(<a href="https://git-wip-us.apache.org/repos/asf?p=trafficserver.git;a=blob;f=proxy/http/HttpTransact.cc;hb=48d7b25ba8a8229b0471d37cdaa6ef24cc634bb0#l3634">source</a>)</p></div></section><section id="firefox"><h3 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3</a>&nbsp;<a href="#firefox">Firefox</a></h3><div id="rfc.section.A.3.p.1" class="avoidbreakafter"><p>Firefox is a Web browser that retries under the following conditions:</p></div><div id="rfc.figure.u.4"><pre>
// if the connection was reset or closed before we wrote any part of the
// request or if we wrote the request but didn't receive any part of the
// response and the connection was being reused, then we can (and really
// should) assume that we wrote to a stale connection and we must therefore
// repeat the request over a new connection.
//
// We have decided to retry not only in case of the reused connections, but
// all safe methods(bug 1236277).
//
// NOTE: the conditions under which we will automatically retry the HTTP
// request have to be carefully selected to avoid duplication of the
// request from the point-of-view of the server.  such duplication could
// have dire consequences including repeated purchases, etc.
//
// NOTE: because of the way SSL proxy CONNECT is implemented, it is
// possible that the transaction may have received data without having
// sent any data.  for this reason, mSendData == FALSE does not imply
// mReceivedData == FALSE.  (see bug 203057 for more info.)
//

[...]

   if (!mReceivedData &amp;&amp;
       ((mRequestHead &amp;&amp; mRequestHead-&gt;IsSafeMethod()) ||
        !reallySentData || connReused)) {
       // if restarting fails, then we must proceed to close the pipe,
       // which will notify the channel that the transaction failed.
</pre></div><div id="rfc.section.A.3.p.2"><p>(<a href="http://mxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpTransaction.cpp#938">source</a>)</p></div><div id="rfc.section.A.3.p.3" class="avoidbreakafter"><p>… and it considers GET, HEAD, OPTIONS, TRACE, PROPFIND, REPORT, and SEARCH to be safe:</p></div><div id="rfc.figure.u.5"><pre>
bool
nsHttpRequestHead::IsSafeMethod() const
{
  // This code will need to be extended for new safe methods, otherwise
  // they'll default to "not safe".
    if (IsGet() || IsHead() || IsOptions() || IsTrace()) {
        return true;
    }

    if (mParsedMethod != kMethod_Custom) {
        return false;
    }

    return (!strcmp(mMethod.get(), "PROPFIND") ||
            !strcmp(mMethod.get(), "REPORT") ||
            !strcmp(mMethod.get(), "SEARCH"));
}
</pre></div><div id="rfc.section.A.3.p.4"><p>(<a href="http://mxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpRequestHead.cpp#67">source</a>)</p></div><div id="rfc.section.A.3.p.5"><p>Note that <span class="tt">connReused</span> is tested; if a connection has been used before, Firefox will retry <em>any</em> request, safe or not. A recent change attempted to remove this behaviour, but it caused <a href="https://www.fxsitecompat.com/en-CA/docs/2016/post-request-fails-on-certain-sites-showing-connection-reset-page/">compatibility problems</a>, and is being backed out.</p></div></section><section id="chromium"><h3 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4</a>&nbsp;<a href="#chromium">Chromium</a></h3><div id="rfc.section.A.4.p.1" class="avoidbreakafter"><p>Chromium is a Web browser that appears to retry any request when a connection is broken, as long as it’s successfully used the connection before, and hasn’t received any response headers yet:</p></div><div id="rfc.figure.u.6"><pre>
bool HttpNetworkTransaction::ShouldResendRequest() const {
  bool connection_is_proven = stream_-&gt;IsConnectionReused();
  bool has_received_headers = GetResponseHeaders() != NULL;

  // NOTE: we resend a request only if we reused a keep-alive connection.
  // This automatically prevents an infinite resend loop because we'll run
  // out of the cached keep-alive connections eventually.
  if (connection_is_proven &amp;&amp; !has_received_headers)
    return true;
  return false;
}
</pre></div><div id="rfc.section.A.4.p.2"><p>(<a href="https://chromium.googlesource.com/chromium/src.git/+/master/net/http/http_network_transaction.cc#1657">source</a>)</p></div></section><section id="curl"><h3 id="rfc.section.A.5"><a href="#rfc.section.A.5">A.5</a>&nbsp;<a href="#curl">Curl</a></h3><div id="rfc.section.A.5.p.1"><p>Curl is both a command-line client and widely-used library for HTTP. Like Chromium, it will retry a request if the response hasn’t started.</p></div><div id="rfc.figure.u.7"><pre>
CURLcode Curl_retry_request(struct connectdata *conn,
                            char **url)
{
  struct Curl_easy *data = conn-&gt;data;

  *url = NULL;

  /* if we're talking upload, we can't do the checks below, unless the protocol
     is HTTP as when uploading over HTTP we will still get a response */
  if(data-&gt;set.upload &amp;&amp;
     !(conn-&gt;handler-&gt;protocol&amp;(PROTO_FAMILY_HTTP|CURLPROTO_RTSP)))
    return CURLE_OK;

  if((data-&gt;req.bytecount + data-&gt;req.headerbytecount == 0) &amp;&amp;
     conn-&gt;bits.reuse &amp;&amp;
     (data-&gt;set.rtspreq != RTSPREQ_RECEIVE)) {
    /* We didn't get a single byte when we attempted to re-use a
       connection. This might happen if the connection was left alive when we
       were done using it before, but that was closed when we wanted to use it
       again. Bad luck. Retry the same request on a fresh connect! */
    infof(conn-&gt;data, "Connection died, retrying a fresh connect\n");
    *url = strdup(conn-&gt;data-&gt;change.url);
    if(!*url)
      return CURLE_OUT_OF_MEMORY;

    connclose(conn, "retry"); /* close this connection */
    conn-&gt;bits.retry = TRUE; /* mark this as a connection we're about
                                to retry. Marking it this way should
                                prevent i.e HTTP transfers to return
                                error just because nothing has been
                                transferred! */


    if(conn-&gt;handler-&gt;protocol&amp;PROTO_FAMILY_HTTP) {
      struct HTTP *http = data-&gt;req.protop;
      if(http-&gt;writebytecount)
        return Curl_readrewind(conn);
    }
  }
  return CURLE_OK;
}
</pre></div><div id="rfc.section.A.5.p.2"><p>(<a href="https://github.com/curl/curl/blob/master/lib/transfer.c#L1892">source</a>)</p></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><p><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></p></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>