<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Defining HTTP/2 Server Push More Carefully</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="../Tools/bower_components/bootstrap/dist/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Server Push and HTTP Semantics" href="#rfc.section.2"><link rel="Chapter" title="3 Interaction with HTTP/2 Features" href="#rfc.section.3"><link rel="Chapter" title="4 IANA Considerations" href="#rfc.section.4"><link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5"><link rel="Chapter" href="#rfc.section.6" title="6 References"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="push"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-pushopedia-00"><meta name="dcterms.issued" content="2016-08-23"><meta name="dcterms.abstract" content="This document explores the use and implementation of HTTP/2 Server Push, in order to formulate recommendations about use and implementation."><meta name="description" content="This document explores the use and implementation of HTTP/2 Server Push, in order to formulate recommendations about use and implementation."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc..toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#server-push-and-http-semantics">Server Push and HTTP Semantics</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#method">HTTP Methods</a></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#status">HTTP Status Codes</a></li><li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#conditional">Conditional Requests</a><ul><li><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#if-match-if-unmodified-since">If-Match / If-Unmodified-Since</a></li><li><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#if-none-match-if-modified-since">If-None-Match / If-Modified-Since</a></li><li><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#not-modified-without-a-conditional">304 (Not Modified) without a Conditional</a></li></ul></li><li><a href="#rfc.section.2.4">2.4</a>&nbsp;&nbsp;&nbsp;<a href="#conneg">Content Negotiation</a></li><li><a href="#rfc.section.2.5">2.5</a>&nbsp;&nbsp;&nbsp;<a href="#cache">Caching</a><ul><li><a href="#rfc.section.2.5.1">2.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#scope">Caching and Scope of Server Push</a></li><li><a href="#rfc.section.2.5.2">2.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#matching-pushes-to-cache-entries">Matching Pushes to Cache Entries</a></li><li><a href="#rfc.section.2.5.3">2.5.3</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-uncacheable-content">Pushing Uncacheable Content</a></li><li><a href="#rfc.section.2.5.4">2.5.4</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-with-max-age0-no-cache">Pushing with max-age=0, no-cache</a></li><li><a href="#rfc.section.2.5.5">2.5.5</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-stale-content">Pushing Stale Content</a></li><li><a href="#rfc.section.2.5.6">2.5.6</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-and-invalidation">Pushing and Invalidation</a></li></ul></li><li><a href="#rfc.section.2.6">2.6</a>&nbsp;&nbsp;&nbsp;<a href="#partial">Partial Content</a></li><li><a href="#rfc.section.2.7">2.7</a>&nbsp;&nbsp;&nbsp;<a href="#auth">Authentication</a></li><li><a href="#rfc.section.2.8">2.8</a>&nbsp;&nbsp;&nbsp;<a href="#headers">Push and Other HTTP Headers</a></li><li><a href="#rfc.section.2.9">2.9</a>&nbsp;&nbsp;&nbsp;<a href="#cors">CORS</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#h2">Interaction with HTTP/2 Features</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#priority">Priorities</a></li><li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#coalesce">Connection Coalescing</a></li><li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#refusing-pushes">Refusing Pushes</a><ul><li><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#pushiscached">PUSH_IS_CACHED</a></li><li><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#pushunauthoritative">PUSH_UNAUTHORITATIVE</a></li><li><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#pushcontentencodingnotsupported">PUSH_CONTENT_ENCODING_NOT_SUPPORTED</a></li></ul></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">August 23, 2016</td></tr><tr><td class="text-left">Intended status: Informational</td><td class="text-right"></td></tr><tr><td class="text-left">Expires: February 24, 2017</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Defining HTTP/2 Server Push More Carefully</h1><div class="filename">draft-nottingham-pushopedia-00</div></div></header><hr><h2 id="rfc..abstract"><a href="#rfc..abstract">Abstract</a></h2><div class="lead"><p>This document explores the use and implementation of HTTP/2 Server Push, in order to formulate recommendations about use and implementation.</p></div><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on February 24, 2017.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2016 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> defines Server Push as a mechanism for servers to “push” request/response pairs to clients.</p></div><div id="rfc.section.1.p.2"><p>The initial use case for Server Push is saving a round trip of latency when additional content is referenced. For example, when a HTML page references CSS and JavaScript resources, the browser needs to receive the HTML response before it can fetch those resources. Server Push allows the server to proactively send them, in anticipation of the browser’s imminent need.</p></div><div id="rfc.section.1.p.3"><p>Server Push is now supported by most Web browsers, and sites are starting to experiment with it. In doing so, it’s become apparent that client handling of server push is not well-defined, leading to divergence in browser behaviour.</p></div><div id="rfc.section.1.p.4"><p>Furthermore, it appears that some deployments tend to treat Server Push like a “magic bullet”, pushing far more data that could usefully fill the idle time on the connection.</p></div><div id="rfc.section.1.p.5"><p>To improve this, this document explores how Server Push interacts with various HTTP features, with recommendations both for using Server Push in servers, and handling it by clients.</p></div><div id="rfc.section.1.p.6"><p>It’s not so much of a specification, for now, as it is a collection of ideas about how Server Push <strong>ought</strong> to work.</p></div><div id="rfc.section.1.p.7"><p>It also does not address other use cases for Server Push, such as store-and-forward or publish-and-subscribe.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><section id="server-push-and-http-semantics"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#server-push-and-http-semantics">Server Push and HTTP Semantics</a></h2><section id="method"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#method">HTTP Methods</a></h3><div id="rfc.section.2.1.p.1"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 requires that promised requests be cacheable, safe, and not have a request body.</p></div><div id="rfc.section.2.1.p.2"><p>In practice, this means that GET and HEAD can be pushed. A few other methods are cacheable and safe, but since a request body is prohibited (both by the HTTP/2 spec and wire format), it’s not practical to use them.</p></div><div id="rfc.section.2.1.p.3"><p>GET operates as we’d expect; it makes a representation available as if it had been previously requested and cached, roughly.</p></div><div id="rfc.section.2.1.p.4"><p>In theory, HEAD should operate in a similar fashion; it would be as if the client had performed a HEAD and used the pushed response to update the cache, as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.3.5 (“Freshening Responses via HEAD”). This might be useful, for example, to update the metadata of that response. However, the same effect can also be achieved by using a conditional request; see <a href="#conditional" title="Conditional Requests">Section&nbsp;2.3</a>.</p></div><div id="rfc.section.2.1.p.5"><p>Of other status codes, perhaps the most interesting would be OPTIONS, because of its use by CORS (<a href="#WHATWG.fetch"><cite title="Fetch">[WHATWG.fetch]</cite></a>). See <a href="#cors" title="CORS">Section&nbsp;2.9</a>.</p></div></section><section id="status"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a href="#status">HTTP Status Codes</a></h3><div id="rfc.section.2.2.p.1"><p>In principle, any HTTP status code can be pushed in a response. Success (2xx), redirection (300, 301, 302, 303, 307, 308) and eror (4xx and 5xx) status codes all have the same caching semantics, described in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>.</p></div><div id="rfc.section.2.2.p.2"><p>This implies that if they are pushed to the client, any of these status codes should behave as if the client had requested them previously and stored the response. For example, a 403 (Forbidden) can be pushed and stored just as a 200 (OK) – even if this would be of very limited use.</p></div><div id="rfc.section.2.2.p.3"><p>There are a few complications to consider, however.</p></div><div id="rfc.section.2.2.p.4"><ul><li>304 (Not Modified) has special interaction with caches and validation that is described in <a href="#conditional" title="Conditional Requests">Section&nbsp;2.3</a>.</li><li>Other 3xx Redirection codes indicate, when pushed, that if the client were to make that request, it will be redirected. That does not mean that the <span class="tt">Location</span> header’s URL should be followed immediately; it is only upon an actual request from the client that it should be acted upon. Therefore, the caching semantics of 3xx redirects take effect.</li><li>1xx Informational codes don’t make much sense as a Push payload, because the headers they convey are lost in most implementations (to be subsumed by the headers in the final response). For example, the headers on a 100 (Continue) response are a no-op; effectively, it’s a one-bit “go ahead” signal. Since HTTP/2 already has protocol-level signalling mechanisms, it’s probably best to say that 1xx responses SHOULD NOT be sent in Server Push, and MUST be ignored when received.</li><li>401 (Unauthenticated) and 407 (Proxy-Authenticate) are covered in <a href="#auth" title="Authentication">Section&nbsp;2.7</a>.</li><li>Many other 4xx and 5xx status codes don’t have any practical use in Server Push; e.g., 405 (Method Not Allowed), 408 (Request Timeout), 411 (Length Required) and 414 (URI Too Long) are all reactions to problems with the request. Since the server has sent that request, their use is somewhat self-defeating; however, this does not mean that a client encountering them should generate an error, or fail to use the response. At the very least, if the response is available in devtools, debugging will be easier; additionally, someone might find a creative, appropriate use for them some day.</li></ul></div></section><section id="conditional"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a href="#conditional">Conditional Requests</a></h3><section id="if-match-if-unmodified-since"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a href="#if-match-if-unmodified-since">If-Match / If-Unmodified-Since</a></h4><div id="rfc.section.2.3.1.p.1"><p>If the server has immediate access to the response being pushed (e.g., if the server is authoritative for it, or it is fresh in cache), it might want to send conditional headers in the <span class="tt">PUSH_PROMISE</span> request.</p></div><div id="rfc.section.2.3.1.p.2"><p>For example, a request can be sent with <span class="tt">If-Match</span> and/or <span class="tt">If-Unmodified-Since</span> to give the client the earliest possible chance to send a <span class="tt">RST_STREAM</span> on the promise, without the server starting the pushed response.</p></div><div id="rfc.figure.u.1"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/1234.jpg
Host: www.example.com
If-Match: "abcdef"
</pre></div><div id="rfc.section.2.3.1.p.3"><p>Here, when a client receives these headers in a <span class="tt">PUSH_PROMISE</span>, it can send a <span class="tt">RST_STREAM</span> if it has a fresh cached response for <span class="tt">https://www.example.com/images/1234.jpg</span> with the <span class="tt">ETag</span> “abcdef”. If it does not do so, the server will continue to push the successful (<span class="tt">2xx</span>) response (since the <span class="tt">ETag</span> does in fact match what is pushed).</p></div></section><section id="if-none-match-if-modified-since"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;<a href="#if-none-match-if-modified-since">If-None-Match / If-Modified-Since</a></h4><div id="rfc.section.2.3.2.p.1" class="avoidbreakafter"><p>If the server does not have a fresh local copy of the response, but does have access to a stale one (in the meaning of <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>), it can <span class="tt">PUSH_PROMISE</span> with <span class="tt">If-None-Match</span> and/or <span class="tt">If-Modified-Since</span>:</p></div><div id="rfc.figure.u.2"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/5678.jpg
Host: www.example.com
If-None-Match: "lmnop"
</pre></div><div id="rfc.section.2.3.2.p.2"><p>That way, the client again has an opportunity to send <span class="tt">RST_STREAM</span> if it already has a fresh copy in cache.</p></div><div id="rfc.section.2.3.2.p.3"><p>Once the server has obtained a fresh (possibly validated) response, it can either push a <span class="tt">304 (Not Modified)</span> response in the case that the <span class="tt">ETag</span> hasn’t changed, or a successful (<span class="tt">2xx</span>) response if it has.</p></div><div id="rfc.section.2.3.2.p.4"><p>Note that if the client has a fresh copy in cache, but the server does not, the client can still use the fresh copy; it has not been invalidated just because the server has not kept its copy fresh.</p></div></section><section id="not-modified-without-a-conditional"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;<a href="#not-modified-without-a-conditional">304 (Not Modified) without a Conditional</a></h4><div id="rfc.section.2.3.3.p.1"><p>If the server believes that the client does have a stale but valid copy in its cache (e.g., through the use of a cache digest; see <a href="#I-D.ietf-httpbis-cache-digest"><cite title="Cache Digests for HTTP/2">[I-D.ietf-httpbis-cache-digest]</cite></a>), it can send a <span class="tt">PUSH_PROMISE</span> followed by a pushed <span class="tt">304 (Not Modified)</span> response to revalidate that cached response, thereby making it fresh in the client’s cache.</p></div><div id="rfc.section.2.3.3.p.2"><p>If the server has a local copy of the response that it wishes to use, it can send the PUSH_PROMISE with an <span class="tt">If-None-Match</span> and/or <span class="tt">If-Modified-Since</span> conditional, as above.</p></div><div id="rfc.section.2.3.3.p.3"><p>However, if it does not, it will still be desirable to generate the <span class="tt">PUSH_PROMISE</span> as soon as possible, so as to avoid the race described in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2.1.</p></div><div id="rfc.section.2.3.3.p.4" class="avoidbreakafter"><p>To allow this, a request without a conditional can be sent:</p></div><div id="rfc.figure.u.3"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/9012.jpg
Host: www.example.com
</pre></div><div id="rfc.section.2.3.3.p.5" class="avoidbreakafter"><p>When the response body is available to the server, it can send a <span class="tt">304 (Not Modified)</span> if it believes that the client already holds a copy (fresh or stale); however, it MUST include the validators to allow the client to confirm this. For example:</p></div><div id="rfc.figure.u.4"><pre>
:status: 304
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600
</pre></div><div id="rfc.section.2.3.3.p.6"><p>In this case, if the client’s cached response does not have the same <span class="tt">ETag</span> it SHOULD re-issue the request to obtain a fresh response.</p></div><div id="rfc.section.2.3.3.p.7" class="avoidbreakafter"><p>On the other hand, if the server determines that the client does not have the appropriate cached response, it can send the full, successful (<span class="tt">2xx</span>) response:</p></div><div id="rfc.figure.u.5"><pre>
:status: 200
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600

[ body ]
</pre></div><div id="rfc.section.2.3.3.p.8"><p><strong>EDITOR’S NOTE</strong>: This approach relies upon an <em>implicit conditional</em> in the PUSH_PROMISE request. If felt necessary, this can be made explicit, for example by defining a new conditional header <span class="tt">If-In-Digest</span>.</p></div></section></section><section id="conneg"><h3 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a href="#conneg">Content Negotiation</a></h3><div id="rfc.section.2.4.p.1"><p>The interaction of Content Negotiation and Server Push is tricky, because it requires the server to guess what the client would have sent, in order to negotiate upon it.</p></div><div id="rfc.section.2.4.p.2"><p>However, it becomes much simpler if we assume that the client SHOULD NOT check a <span class="tt">PUSH_PROMISE</span> request’s headers to see whether or not it would have sent that request.</p></div><div id="rfc.section.2.4.p.3"><p>This means, for example, that if you <span class="tt">PUSH_PROMISE</span> the “wrong” <span class="tt">User-Agent</span>, <span class="tt">Accept-Encoding</span>, <span class="tt">User-Agent</span> or even <span class="tt">Cookie</span> header field, the client SHOULD still use the pushed response; all they’re looking for is a matching request method and URL.</p></div><div id="rfc.section.2.4.p.4" class="avoidbreakafter"><p>However, this does imply a few things:</p></div><div id="rfc.section.2.4.p.5"><ul><li>The pushed request and response MUST still “agree”; i.e., if you’re using gzip encoding, <span class="tt">Accept-Encoding</span> and <span class="tt">Content-Encoding</span> should be pushed with appropriate values.</li><li>The pushed response MUST have an appropriate <span class="tt">Vary</span> header field, if it is cacheable. This is so that the cache operates properly.</li></ul></div><div id="rfc.section.2.4.p.6"><p>Additionally, the server needs to know what the base capabilities and preferences of the client are, to allow it to select the appropriate responses to push. To aid this, we suggest that servers create a response by copying the values of the request header fields mentioned in the <span class="tt">Vary</span> response header field from the request that is identified by the <span class="tt">PUSH_PROMISE</span> frame’s Stream ID.</p></div><div id="rfc.section.2.4.p.7" class="avoidbreakafter"><p>So, for example, if the first request for a page had the following headers:</p></div><div id="rfc.figure.u.6"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /
User-Agent: FooAgent/1.0
Accept-Encoding: gzip, br
Accept-Language: en, fr
Accept: text/html,s application/example, image/*
Cookie: abc=123
</pre></div><div id="rfc.section.2.4.p.8" class="avoidbreakafter"><p>and the server wishes to push these response headers for <span class="tt">/images/123.png</span>:</p></div><div id="rfc.figure.u.7"><pre>
:status: 200
Vary: Accept-Encoding
Content-Type: image/png
Cache-Control: max-age=3600
</pre></div><div id="rfc.section.2.4.p.9" class="avoidbreakafter"><p>then it should use these headers for the <span class="tt">PUSH_PROMISE</span>:</p></div><div id="rfc.figure.u.8"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/123.png
Accept-Encoding: gzip, br
Vary: Accept-Encoding
</pre></div><div id="rfc.section.2.4.p.10"><p>This approach has its limits. For example, use of <a href="#I-D.ietf-httpbis-client-hints"><cite title="HTTP Client Hints">[I-D.ietf-httpbis-client-hints]</cite></a> might not be practical with server push (since in some circumstances, hints might change between the base page request and the request for what’s been pushed).</p></div></section><section id="cache"><h3 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5</a>&nbsp;<a href="#cache">Caching</a></h3><div id="rfc.section.2.5.p.1"><p>Server Push has a strong tie to HTTP caching (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>).</p></div><section id="scope"><h4 id="rfc.section.2.5.1"><a href="#rfc.section.2.5.1">2.5.1</a>&nbsp;<a href="#scope">Caching and Scope of Server Push</a></h4><div id="rfc.section.2.5.1.p.1"><p>Currently, browser implementations of Server Push will not inject the pushed response into the HTTP cache until there is a reference to it from the stream that the PUSH_PROMISE was sent upon.</p></div><div id="rfc.section.2.5.1.p.2"><p>This is not specified behaviour, and it has confused some. Reportedly, Firefox ties the affinity of a push to a “load group”, whereas Edge is using a “navigation handle.”</p></div><div id="rfc.section.2.5.1.p.3"><p>Effectively, doing so creates yet another kind of HTTP-ish cache in the browser. See also <a href="https://github.com/whatwg/fetch/issues/354">https://github.com/whatwg/fetch/issues/354</a>.</p></div><div id="rfc.section.2.5.1.p.4" class="avoidbreakafter"><p>Discussion about why these implementations feel this is necessary would be helpful. Possible reasons that have been posited include:</p></div><div id="rfc.section.2.5.1.p.5"><ul><li>Avoiding cache flooding. However, sites already have many ways to flood a cache with responses.</li><li>Avoiding cache poisoning. However, an attacker that has the ability to send a push for an origin can also (presumably) get that push referenced by content there.</li><li>Restricting use of push. Some developers want to push not only the assets for a given page to the client, but also push the next page that they might navigate to. This can be seen as abuse, but again, it’s already possible to fetch that into the cache in the background.</li></ul></div></section><section id="matching-pushes-to-cache-entries"><h4 id="rfc.section.2.5.2"><a href="#rfc.section.2.5.2">2.5.2</a>&nbsp;<a href="#matching-pushes-to-cache-entries">Matching Pushes to Cache Entries</a></h4><div id="rfc.section.2.5.2.p.1"><p>Canonicalisation of request URLs is not specified for server push; presumably, limited canonicalisation (e.g., removing default ports, case-normalising the scheme and authority) are reasonable.</p></div><div id="rfc.section.2.5.2.p.2"><p>This might be specified in terms of origins in <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, since that already specifies a match algorithm that’s believed to conform with reality (roughly).</p></div><div id="rfc.section.2.5.2.p.3"><p>It can be derived from the various specifications, but it would also be good to explicitly say that pushed URLs MUST NOT contain a fragment identifier.s</p></div></section><section id="pushing-uncacheable-content"><h4 id="rfc.section.2.5.3"><a href="#rfc.section.2.5.3">2.5.3</a>&nbsp;<a href="#pushing-uncacheable-content">Pushing Uncacheable Content</a></h4><div id="rfc.section.2.5.3.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 says:</p></div><div id="rfc.section.2.5.3.p.2"><ul class="empty"><li>Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made available to the application separately.</li></ul></div><div id="rfc.section.2.5.3.p.3"><p>As a result, any response that cannot be stored as per the rules in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 3 cannot be stored by a receiving cache.</p></div><div id="rfc.section.2.5.3.p.4"><p>“Being made available to the application separately” could mean many things. It could be that a truly uncacheable response (e.g., with <span class="tt">Cache-Control: no-store</span>) would bypass the HTTP cache but then be stored by the application in anticipation of a future request, but this might lead to some surprising results for Web developers, because it’s effectively specifying yet another kind of browser caching (see <a href="#scope" title="Caching and Scope of Server Push">Section&nbsp;2.5.1</a>).</p></div><div id="rfc.section.2.5.3.p.5"><p>However, they might still be usable if a browser API for Server Push emerges. See <a href="https://github.com/whatwg/fetch/issues/51">https://github.com/whatwg/fetch/issues/51</a>.</p></div></section><section id="pushing-with-max-age0-no-cache"><h4 id="rfc.section.2.5.4"><a href="#rfc.section.2.5.4">2.5.4</a>&nbsp;<a href="#pushing-with-max-age0-no-cache">Pushing with max-age=0, no-cache</a></h4><div id="rfc.section.2.5.4.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 says:</p></div><div id="rfc.section.2.5.4.p.2"><ul class="empty"><li>Pushed responses are considered successfully validated on the origin server (e.g., if the “no-cache” cache response directive is present (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.2.2)) while the stream identified by the promised stream ID is still open.</li></ul></div><div id="rfc.section.2.5.4.p.3" class="avoidbreakafter"><p>This implies that, while that stream is open, the pushed response can be considered fresh, even when it contains any (or all) of the following cache directives:</p></div><div id="rfc.section.2.5.4.p.4"><ul><li>max-age=0</li><li>no-cache</li><li>s-maxage=0 (for shared caches)</li></ul></div><div id="rfc.section.2.5.4.p.5"><p>The underlying principle here is that while the response stream is still open, it’s semantically equivalent to a “normal” response. So, this would also naturally apply to <span class="tt">Expires</span> when the value matches that of the <span class="tt">Date</span> header. It’s less clear whether it would apply to pushed responses with a positive <span class="tt">Age</span> header, or <span class="tt">Expires</span> in the past, but on general principles they SHOULD be considered as just revalidated on the server, and therefore useable without revalidation.</p></div><div id="rfc.section.2.5.4.p.6"><p>This means that the client can: * Pass the response on to the application for consumption * Store the response as stale in the cache</p></div><div id="rfc.section.2.5.4.p.7"><p>Note that HTTP does not put constraints on <em>how</em> the application uses that response; it might use it multiple times (e.g., an image might occur more than once on a page, or more than one downstream client might have made the request). It’s just that this reuse isn’t in the context of a HTTP cache’s operation.</p></div></section><section id="pushing-stale-content"><h4 id="rfc.section.2.5.5"><a href="#rfc.section.2.5.5">2.5.5</a>&nbsp;<a href="#pushing-stale-content">Pushing Stale Content</a></h4><div id="rfc.section.2.5.5.p.1"><p>How client caches should handle a pushed stale response (e.g., with some combination of <span class="tt">Expires</span>, <span class="tt">Date</span>, <span class="tt">Cache-Control</span> and <span class="tt">Age</span> that results in it being considered not fresh, as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.2) is not defined by HTTP/2.</p></div><div id="rfc.section.2.5.5.p.2"><p>This also applies to content that was fresh when it was pushed, but has become stale since that stream closed.</p></div><div id="rfc.section.2.5.5.p.3"><p>Strictly interpreting the specifications, it would be necessary to issue a revalidation request for that response. While this seems counter-intuitive at first, it might be interesting to consider doing so as a way of optimistically pre-fetching content into cache, while still giving the server control when it is actually used; if the server wants to permit its use, it can send a simple 304 (Not Modified). Otherwise, it can send a different response.</p></div></section><section id="pushing-and-invalidation"><h4 id="rfc.section.2.5.6"><a href="#rfc.section.2.5.6">2.5.6</a>&nbsp;<a href="#pushing-and-invalidation">Pushing and Invalidation</a></h4><div id="rfc.section.2.5.6.p.1"><p>When a server wants to remove the contents of a client’s cache for a given URL, but doesn’t know what it’s to be replaced with yet, it needs to invalidate.</p></div><div id="rfc.section.2.5.6.p.2" class="avoidbreakafter"><p>The only native HTTP mechanism for cache invalidation is described in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.4:</p></div><div id="rfc.section.2.5.6.p.3"><ul class="empty"><li>A cache MUST invalidate the effective Request URI (Section 5.5 of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>) as well as the URI(s) in the Location and Content-Location response header fields (if present) when a non-error status code is received in response to an unsafe request method.</li></ul></div><div id="rfc.section.2.5.6.p.4"><p>Since it is triggered by unsafe request methods (like POST), this can’t be used in Server Push.</p></div><div id="rfc.section.2.5.6.p.5" class="avoidbreakafter"><p>We <em>could</em> use this loophole a bit further down:</p></div><div id="rfc.section.2.5.6.p.6"><ul class="empty"><li>A cache MUST invalidate the effective request URI (Section 5.5 of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>) when it receives a non-error response to a request with a method whose safety is unknown.</li></ul></div><div id="rfc.section.2.5.6.p.7"><p>… by defining a method that is defined to have a method whose safety is unknown (since if it’s defined, it either won’t be pushable, or won’t trigger invalidation). E.g.</p></div><div id="rfc.figure.u.9"><pre>
:method: INVALIDATE
:scheme: https
:authority: www.example.com
:path: /thing
</pre></div><div id="rfc.section.2.5.6.p.8"><p>However, doing that might cause problems with IANA, since we’d have to pick a value to register.</p></div><div id="rfc.section.2.5.6.p.9"><p>Another approach would be to push a 404 (Not Found) or 410 (Gone) to trigger invalidation. However, Such a push would need to be uncacheable (e.g,. with <span class="tt">Cache-Control: no-store</span>) to assure that the error response wasn’t returned; however, this falls afoul of HTTP/2’s requirement that uncacheable responses not interact with the HTTP cache.</p></div><div id="rfc.section.2.5.6.p.10"><p>If invalidation is an important use case, we’ll need to change one of these specifications, or invent a new protocol mechanism. Maybe a <span class="tt">CACHE_INVALIDATE</span> frame?</p></div></section></section><section id="partial"><h3 id="rfc.section.2.6"><a href="#rfc.section.2.6">2.6</a>&nbsp;<a href="#partial">Partial Content</a></h3><div id="rfc.section.2.6.p.1" class="avoidbreakafter"><p>Conceivably, it might be interesting to push partial content (<a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>) to make some kinds of content available to the client, when pushing the entire response would consume too much bandwidth; e.g.:</p></div><div id="rfc.section.2.6.p.2"><ul><li>The index portion of a PDF file</li><li>The first segments or a video or audio file (and, in some formats, the last)</li><li>The header of an image file, as it might contain layout-critical metadata</li></ul></div><div id="rfc.section.2.6.p.3"><p>However, it’s believed that support for partial content in many caches (in particular, browser caches) is poor.</p></div></section><section id="auth"><h3 id="rfc.section.2.7"><a href="#rfc.section.2.7">2.7</a>&nbsp;<a href="#auth">Authentication</a></h3><div id="rfc.section.2.7.p.1"><p>401 (Unauthorized) has the side effect of prompting the user for their credentials. Again, this does not mean that the User Agent ought to do so when receiving a pushed 401; rather, this could be seen as a mechanism to avoid the round trip that would otherwise be required – just as in other intended uses of Server Push.</p></div><div id="rfc.section.2.7.p.2"><p>Presumably, the PUSH_PROMISE for such a request would omit the <span class="tt">Authentication</span> header field.</p></div><div id="rfc.section.2.7.p.3"><p>407 (Proxy Authenticate) is probably best not to push, since it’s confusing authority of the network vs. the origin. Clients SHOULD ignore such pushes.</p></div></section><section id="headers"><h3 id="rfc.section.2.8"><a href="#rfc.section.2.8">2.8</a>&nbsp;<a href="#headers">Push and Other HTTP Headers</a></h3><div id="rfc.section.2.8.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2.1 says:</p></div><div id="rfc.section.2.8.p.2"><ul class="empty"><li>If a client receives a PUSH_PROMISE that does not include a complete and valid set of header fields or the :method pseudo-header field identifies a method that is not safe, it MUST respond with a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</li></ul></div><div id="rfc.section.2.8.p.3"><p>“Complete” in this context is a bit fuzzy. The strictest reading would be that it MUST include the required pseudo-headers, along with any request headers specified by a later <span class="tt">Vary</span> (as discussed in <a href="#conneg" title="Content Negotiation">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.2.8.p.4"><p>There are a few headers that are interesting to consider, however.</p></div><div id="rfc.section.2.8.p.5"><p>Use of the <span class="tt">Host</span> request header field is discouraged in HTTP/2, and SHOULD be omitted.</p></div><div id="rfc.section.2.8.p.6"><p>The following request headers could be copied from the parent Stream ID’s request, but are unlikely to be useful (unless specified in <span class="tt">Vary</span>), and SHOULD be omitted otherwise: * <span class="tt">User-Agent</span> * <span class="tt">Cookie</span> * <span class="tt">DNT</span></p></div><div id="rfc.section.2.8.p.7"><p>The <span class="tt">Referer</span> header could be copied from the parent Stream ID’s request, but in most cases this would be a waste of bytes; it SHOULD be omitted.</p></div><div id="rfc.section.2.8.p.8"><p><span class="tt">Expect</span> doesn’t make much sense in a push, as discussed in <a href="#status" title="HTTP Status Codes">Section&nbsp;2.2</a>; it SHOULD be omitted.</p></div><div id="rfc.section.2.8.p.9"><p><span class="tt">Origin</span> is discussed in <a href="#cors" title="CORS">Section&nbsp;2.9</a>.</p></div><div id="rfc.section.2.8.p.10"><p>As described in <a href="#conneg" title="Content Negotiation">Section&nbsp;2.4</a>, none of these headers should cause a client to ignore the push or generate an error.</p></div></section><section id="cors"><h3 id="rfc.section.2.9"><a href="#rfc.section.2.9">2.9</a>&nbsp;<a href="#cors">CORS</a></h3><div id="rfc.section.2.9.p.1"><p><a href="#WHATWG.fetch"><cite title="Fetch">[WHATWG.fetch]</cite></a> defines CORS, which uses the OPTIONS method to pre-flight certain requests to assure that the server has opted into them, as well as discover what headers and methods are allowed on such a request.</p></div><div id="rfc.section.2.9.p.2"><p>OPTIONS is safe and (in this case) does not have a request body (although technically, it has a zero-length body, that can probably be overlooked).</p></div><div id="rfc.section.2.9.p.3"><p>Pushing OPTIONS as a means of pre-seeding CORS information would only work in very limited circumstances; because CORS is, by nature, cross-origin, the two origins in question would need some way of coordinating the push; the first origin would effectively tell the second origin that a request is imminent, so it should initiate a push.</p></div><div id="rfc.section.2.9.p.4"><p>This seems fairly unlikely, unless the origins have an unusually close relationship. Conceivably, this might be possible if the origins are coalesced onto the same connection, since they would be represented by the same server.</p></div><div id="rfc.section.2.9.p.5"><p>Whether or not it’s worth the specification and implementation work remains a separate question, especially when conveying site-wide CORS information via other mechanisms is under discussion.</p></div><div id="rfc.section.2.9.p.6"><p>CORS also defines the use of several headers to control the reuse of content across origins. Presumably these would operate the same way whether or not they are pushed. Notably, the <span class="tt">Origin</span> request header is used to determine where the content that originated the request is from.</p></div><div id="rfc.section.2.9.p.7" class="avoidbreakafter"><p>For example, a HTML page at <span class="tt">https://www.example.com/thing</span> would send:</p></div><div id="rfc.section.2.9.p.8"><ul class="empty"><li>Origin: https://www.example.com/</li></ul></div><div id="rfc.section.2.9.p.9"><p>when loading content from <span class="tt">https://other.example.net/foo</span>.</p></div><div id="rfc.section.2.9.p.10" class="avoidbreakafter"><p>If the returned content has a header:</p></div><div id="rfc.section.2.9.p.11"><ul class="empty"><li>Access-Control-Allow-Origin: https://www.example.com/</li></ul></div><div id="rfc.section.2.9.p.12"><p>then the browser will allow the page to have access to that content.</p></div><div id="rfc.section.2.9.p.13"><p>It’s not clear how this interacts with server push. Presumably, it will ignore the value of any <span class="tt">Origin</span> header in the PUSH_PROMISE, synthesising an appropriate value.</p></div><div id="rfc.section.2.9.p.14"><p>However, the PUSH_PROMISE might still need to send an Origin header value, if the response contains <span class="tt">Vary: Origin</span>; otherwise, a cached response might be incorrectly used for another origin’s request.</p></div></section></section><section id="h2"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#h2">Interaction with HTTP/2 Features</a></h2><section id="priority"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#priority">Priorities</a></h3><div id="rfc.section.3.1.p.1"><p>See recent discussion on-list.</p></div></section><section id="coalesce"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#coalesce">Connection Coalescing</a></h3><div id="rfc.section.3.2.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 says:</p></div><div id="rfc.section.3.2.p.2"><ul class="empty"><li>The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</li></ul></div><div id="rfc.section.3.2.p.3"><p>Interestingly, it does not say anything about the relationship of the authority of the stream which a PUSH_PROMISE appears upon and its embedded request. Is it valid (and a good idea) for a stream from <span class="tt">foo.example.com</span> to push a stream to <span class="tt">bar.example.net</span> (for example)?</p></div></section><section id="refusing-pushes"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a href="#refusing-pushes">Refusing Pushes</a></h3><div id="rfc.section.3.3.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2.2 says:</p></div><div id="rfc.section.3.3.p.2"><ul class="empty"><li>Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed. If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code and referencing the pushed stream’s identifier.</li></ul></div><div id="rfc.section.3.3.p.3"><p>Unfortunately, this doesn’t give the server much information about why the push was refused. New HTTP error codes are collected below, in an attempt to start to give this information.</p></div><section id="pushiscached"><h4 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a href="#pushiscached">PUSH_IS_CACHED</a></h4><div id="rfc.section.3.3.1.p.1"><ul><li>Name: PUSH_IS_CACHED</li><li>Code: 0xNN</li><li>Description: On a RST_STREAM sent on a pushed stream, indicates that the sender already had a fresh cached response, and did not need to update it.</li><li>Specification: [this document]</li></ul></div></section><section id="pushunauthoritative"><h4 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a href="#pushunauthoritative">PUSH_UNAUTHORITATIVE</a></h4><div id="rfc.section.3.3.2.p.1"><ul><li>Name: PUSH_UNAUTHORITATIVE</li><li>Code: 0xNN</li><li>Description: On a RST_STREAM sent on a pushed stream, indicates that the server is not considered authoritative for the origin of the pushed request.</li><li>Specification: [this document]</li></ul></div><div id="rfc.section.3.3.2.p.2" class="avoidbreakafter"><p>Note that this would need to overrule the following requirement in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2:</p></div><div id="rfc.section.3.3.2.p.3"><ul class="empty"><li>The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</li></ul></div></section><section id="pushcontentencodingnotsupported"><h4 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;<a href="#pushcontentencodingnotsupported">PUSH_CONTENT_ENCODING_NOT_SUPPORTED</a></h4><div id="rfc.section.3.3.3.p.1"><ul><li>Name: PUSH_CONTENT_ENCODING_NOT_SUPPORTED</li><li>Code: 0xNN</li><li>Description: On a RST_STREAM sent on a pushed stream, indicates that the content-coding of the response is not supported by the client.</li><li>Specification: [this document]</li></ul></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.4.p.1"><p>TBD</p></div></section><section id="security-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.5.p.1"><p>Undoubtedly.</p></div></section><section id="rfc.references"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC6454">[RFC6454]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC&nbsp;6454, <a href="http://dx.doi.org/10.17487/RFC6454">DOI&nbsp;10.17487/RFC6454</a>, December&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6454">http://www.rfc-editor.org/info/rfc6454</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7233">[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7233">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, RFC&nbsp;7233, <a href="http://dx.doi.org/10.17487/RFC7233">DOI&nbsp;10.17487/RFC7233</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7233">http://www.rfc-editor.org/info/rfc7233</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a> Informative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-httpbis-cache-digest">[I-D.ietf-httpbis-cache-digest]</dt><dd>Oku, K. and M. Nottingham, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cache-digest-00">Cache Digests for HTTP/2</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-cache-digest-00 (work in progress), July&nbsp;2016.</dd><dt id="I-D.ietf-httpbis-client-hints">[I-D.ietf-httpbis-client-hints]</dt><dd>Grigorik, I., “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-01">HTTP Client Hints</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-client-hints-01 (work in progress), May&nbsp;2016.</dd><dt id="WHATWG.fetch">[WHATWG.fetch]</dt><dd>WHAT Working Group, “<a href="https://fetch.spec.whatwg.org/">Fetch</a>”, 2016, &lt;<a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>&gt;.</dd></dl></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><p><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></p></section></div></div></div><script src="../Tools/bower_components/jquery/dist/jquery.min.js"></script><script src="../Tools/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></body></html>