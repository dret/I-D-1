<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.22 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-http-encryption-encoding-00" category="info">

  <front>
    <title abbrev="HTTP encryption coding">Encrypted Content-Encoding for HTTP</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>http://www.mnot.net/</uri>
      </address>
    </author>
    <author initials="M." surname="Thomson" fullname="Martin Thomson">
      <organization>Mozilla</organization>
      <address>
        <email>martin.thomson@gmail.com</email>
      </address>
    </author>

    <date year="2015"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This memo introduces a content-coding for HTTP that allows message payloads to be encrypted.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>It is sometimes desirable to encrypt the contents of a HTTP message (request or response) in a
persistent manner, so that when the payload is stored (e.g., with a HTTP PUT), only someone with
the appropriate key can read it.</t>

<t>For example, it might be necessary to store a file on a server without exposing its contents to
that server. Furthermore, that same file could be replicated to other servers (to make it more
resistant to server or network failure), downloaded by clients (to make it available offline), etc.
without exposing its contents.</t>

<t>These uses are not met by the use of TLS <xref target="RFC5246"></xref>, since it only encrypts the channel between the
client and server.</t>

<t>Message-based encryption formats - such as those that are described by <xref target="RFC4880"></xref>, <xref target="RFC5652"></xref>,
<xref target="I-D.ietf-jose-json-web-encryption"></xref>, and <xref target="XMLENC"></xref> - are not suited to stream processing, which is
necessary for HTTP messages.  While virtually any of these alternatives could be profiled and
adapted to suit, the overhead and complexity that would introduce is sub-optimal.</t>

<t>This document specifies a content-coding <xref target="RFC7231"></xref>) for HTTP to serve these and other use cases.</t>

<t>This mechanism is likely only a small part of a larger design that uses content encryption.  In
particular, this document does not describe key management practices.  How clients and servers
acquire and identify keys will depend on the use case.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"></xref>.</t>

</section>
</section>
<section anchor="aesgcm128" title="The “aesgcm-128” HTTP content-coding">

<t>The “aesgcm-128” HTTP content-coding indicates that a payload has been encrypted using Advanced
Encryption Standard (AES) in Galois/Counter Mode (GCM) as identified as AEAD_AES_128_GCM in
<xref target="RFC5116"></xref>, Section 5.1.  The AEAD_AES_128_GCM algorithm uses a 128 bit content encryption key.</t>

<t>When this content-coding is in use, the Encryption header field <xref target="encryption"/> describes how
encryption has been applied.  The Encryption-Key header field <xref target="encryption-key"/> can be included to
describe how the the content encryption key is derived or retrieved.</t>

<t>The “aesgcm-128” content-coding uses a single fixed set of encryption primitives.  Cipher suite
agility is achieved by defining a new content-coding scheme.  This ensures that only the HTTP
Accept-Encoding header field is necessary to negotiate the use of encryption.</t>

<t>The “aesgcm-128” content-coding uses a fixed record size.  The resulting encoding is a series of
fixed-size records, though the final record can contain any amount of data.</t>

<figure><artwork><![CDATA[
       +------+
       | data |         input of between rs-256
       +------+            and rs-1 octets
           |
           v
+-----+-----------+
| pad |   data    |     add padding to form plaintext
+-----+-----------+
         |
         v
+--------------------+
|    ciphertext      |  encrypt with AEAD_AES_128_GCM
+--------------------+     expands by 16 octets
]]></artwork></figure>

<t>The record size determines the length of each portion of plaintext that is enciphered.  The record
size defaults to 4096 octets, but can be changed using the “rs” parameter on the Encryption header
field.</t>

<t>AEAD_AES_128_GCM expands ciphertext to be 16 octets longer than its input plaintext.  Therefore, the
length of each enciphered record is equal to the value of the “rs” parameter plus 16 octets.  It is
a fatal decryption error to have a remainder of 16 octets or less in size (though AEAD_AES_128_GCM
permits input plaintext to be zero length, records always contain at least one padding octet).</t>

<t>Each record contains between 0 and 255 octets of padding, inserted into a record before the
enciphered content.  The length of the padding is stored in the first octet of the payload.  All
padding octets MUST be set to zero.  It is a fatal decryption error to have a record with more
padding than the record size.</t>

<t>The nonce used for each record is a 96-bit value containing the index of the current record in
network byte order.  Records are indexed starting at zero.</t>

<t>The additional data passed to the AEAD algorithm is a zero-length octet sequence.</t>

<t><list style="hanging">
  <t hangText='Issue:'>
  Double check that having no AAD is safe.</t>
</list></t>

</section>
<section anchor="encryption" title="The “Encryption” HTTP header field">

<t>The “Encryption” HTTP header field describes the encrypted content encoding(s) that have been
applied to a message payload, and therefore how those content encoding(s) can be removed.</t>

<figure><artwork><![CDATA[
  Encryption-val = #encryption_params
  encryption_params = [ param *( ";" param ) ]
]]></artwork></figure>

<t>If the payload is encrypted more than once (as reflected by having multiple content-codings that
imply encryption), each application of the content encoding is reflected in the Encryption header
field, in the order in which they were applied.</t>

<t>The Encryption header MAY be omitted if the sender does not intend for the immediate recipient to
be able to decrypt the message.  Alternatively, the Encryption header field MAY be omitted if the
sender intends for the recipient to acquire the header field by other means.</t>

<t>Servers processing PUT requests MUST persist the value of the Encryption header field, unless they
remove the content-coding by decrypting the payload.</t>

<section anchor="encryption-header-field-parameters" title="Encryption Header Field Parameters">

<t>The following parameters are used in determining the key that is used for encryption:</t>

<t><list style="hanging">
  <t hangText='keyid:'>
  The “keyid” parameter contains a string that identifies the keying material that is used.  The
“keyid” parameter SHOULD be included, unless key identification is guaranteed by other means.  The
“keyid” parameter MUST be used if keying material is included in an Encryption-Key header field.</t>
  <t hangText='salt:'>
  The “salt” parameter contains a base64 URL-encoded octets that is used as salt in deriving a
unique content encryption key (see <xref target="derivation"/>).  The “salt” parameter MUST be present, and MUST
be exactly 16 octets long.  The “salt” parameter MUST NOT be reused for two different messages that
have the same content encryption key; generating a random nonce for each message ensures that reuse
is highly unlikely.</t>
  <t hangText='rs:'>
  The “rs” parameter contains a positive decimal integer that describes the record size in octets.
This value MUST be greater than 1.  If the “rs” parameter is absent, the record size defaults to
4096 octets.</t>
</list></t>

</section>
<section anchor="derivation" title="Content Encryption Key Derivation">

<t>In order to allow the reuse of keying material for multiple different messages, a content encryption
key is derived for each message.  This key is derived from the decoded value of the “s” parameter
using the HMAC-based key derivation function (HKDF) described in <xref target="RFC5869"></xref> using the SHA-256 hash
algorithm <xref target="FIPS180-2"></xref>.</t>

<t>The decoded value of the “salt” parameter is the salt input to HKDF function.  The keying material
identified by the “keyid” parameter is the input keying material (IKM) to HKDF.  Input keying
material can either be prearranged, or can be described using the Encryption-Key header field
<xref target="encryption-key"/>.  The first step of HKDF is therefore:</t>

<figure><artwork><![CDATA[
   PRK = HMAC-SHA-256(salt, IKM)
]]></artwork></figure>

<t>AEAD_AES_128_GCM requires 16 octets (128 bits) of key, so the length (L) parameter of HKDF is 16.
The info parameter is set to the ASCII-encoded string “Content-Encoding: aesgcm128”.  The second
step of HKDF can therefore be simplified to the first 16 octets of a single HMAC:</t>

<figure><artwork><![CDATA[
   OKM = HMAC-SHA-256(PRK, "Content-Encoding: aesgcm128" || 0x01)
]]></artwork></figure>

</section>
</section>
<section anchor="encryption-key" title="Encryption-Key Header Field">

<t>An Encryption-Key header field can be used to describe the input keying material used in the
Encryption header field.</t>

<figure><artwork><![CDATA[
  Encryption-Key-val = #encryption_key_params
  encryption_key_params = [ param *( ";" param ) ]
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='keyid:'>
  The “keyid” parameter corresponds to the “keyid” parameter in the Encryption header field.</t>
  <t hangText='key:'>
  The “key” parameter contains the URL-safe base64 <xref target="RFC4648"></xref> octets of the input keying material.</t>
  <t hangText='dh:'>
  The “dh” parameter contains an ephemeral Diffie-Hellman share. This form of the header field can
be used to encrypt content for a specific recipient.</t>
</list></t>

<t>The input keying material used by the content-encoding key derivation (see <xref target="derivation"/>) can be
determined based on the information in the Encryption-Key header field.  The method for key
derivation depends on the parameters that are present in the header field.</t>

<t>Note that different methods for determining input keying materal will produce different
amounts of data.  The HKDF process ensures that the final content encryption key is the necessary
size.</t>

<t>Alternative methods for determining input keying material MAY be defined by specifications that use
this content-encoding.</t>

<section anchor="explicit-key" title="Explicit Key">

<t>The “key” parameter is decoded and used directly if present.  The “key” parameter MUST decode to
exactly 16 octets in order to be used as input keying material for “aesgcm128” content encoding.</t>

<t>Other key determination parameters can be ignored if the “key” parameter is present.</t>

</section>
<section anchor="diffie-hellman" title="Diffie-Hellman">

<t>The “dh” parameter is included to describe a Diffie-Hellman share, either modp (or finite field)
Diffie-Hellman <xref target="DH"></xref> or elliptic curve Diffie-Hellman (ECDH) <xref target="RFC4492"></xref>.</t>

<t>This share is combined with other information at the recipient to determine the HKDF input keying
material.  In order for the exchange to be successful, the following information MUST be established
out of band:</t>

<t><list style="symbols">
  <t>Which Diffie-Hellman form is used.</t>
  <t>The modp group or elliptic curve that will be used.</t>
  <t>The format of the ephemeral public share that is included in the “dh” parameter.  For instance,
using ECDH both parties need to agree whether this is an uncompressed or compressed point.</t>
</list></t>

<t>In addition to identifying which content-encoding this input keying material is used for, the
“keyid” parameter is used to identify this additional information at the receiver.</t>

<t>The intended recipient recovers their private key and are then able to generate a shared secret
using the appropriate Diffie-Hellman process.</t>

<t>Specifications that rely on an Diffie-Hellman exchange for determining input keying material MUST
either specify the parameters for Diffie-Hellman (group parameters, or curves and point format) that
are used, or describe how those parameters are negotiated between sender and receiver.</t>

</section>
</section>
<section anchor="examples" title="Examples">

<section anchor="successful-get-response" title="Successful GET Response">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/octet-stream
Content-Encoding: aesgcm-128
Connection: close
Encryption: keyid="http://example.org/bob/keys/123";
            salt="XZwpw6o37R-6qoZjw6KwAw"

[encrypted payload]
]]></artwork></figure>

<t>Here, a successful HTTP GET response has been encrypted using a key that is identified by a URI.</t>

<t>Note that the media type has been changed to “application/octet-stream” to avoid exposing
information about the content.</t>

</section>
<section anchor="encryption-and-compression" title="Encryption and Compression">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/html
Content-Encoding: aesgcm-128, gzip
Transfer-Encoding: chunked
Encryption: keyid="mailto:me@example.com";
            salt="m2hJ_NttRtFyUiMRPwfpHA"

[encrypted payload]
]]></artwork></figure>

</section>
<section anchor="encryption-with-more-than-one-key" title="Encryption with More Than One Key">

<figure><artwork><![CDATA[
PUT /thing HTTP/1.1
Host: storage.example.com
Content-Type: application/http
Content-Encoding: aesgcm-128, aesgcm-128
Content-Length: 1234
Encryption: keyid="mailto:me@example.com";
            salt="NfzOeuV5USPRA-n_9s1Lag",
            keyid="http://example.org/bob/keys/123";
            salt="bDMSGoc2uobK_IhavSHsHA"; rs=1200

[encrypted payload]
]]></artwork></figure>

<t>Here, a PUT request has been encrypted with two keys; both will be necessary to read the content.
The outer layer of encryption uses a 1200 octet record size.</t>

</section>
<section anchor="encryption-with-explicit-key" title="Encryption with Explicit Key">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Length: 31
Content-Encoding: aesgcm-128
Encryption: keyid="a1"; salt="owIfQR647esVfrzCW_i9GQ"
Encryption-Key: keyid="a1"; key="JcqK-OLkJZlJ3sJJWstJCA"

LwTC-fwdKh8de0smD2jfzHodb1EYbuuTNpcYXLW257Q
]]></artwork></figure>

<t>This example shows the string “I am the walrus” encrypted using an explicit key.  The content body
contains a single record only and is shown here encoded in URL-safe base64 for presentation reasons
only.</t>

</section>
<section anchor="diffie-hellman-encryption" title="Diffie-Hellman Encryption">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Length: 31
Content-Encoding: aesgcm-128
Encryption: keyid="dhkey"; salt="XYFSCgMVjc45IMfLOcMfiw"
Encryption-Key: keyid="dhkey";
                dh="BELKqvZ7n3p5C9_ipP_6X9DBNAGuJujSN7YWbtcGZMMH
                    3urZM-zlii3mGGCMjlqR-yWwiPlMdKRdOL8gQSdHw8E"

P6ikHE_wyKnYHXxLswvuFBO3JJOZpM1Bg3KikQEmczU
]]></artwork></figure>

<t>This example shows the same string, “I am the walrus”, encrypted using ECDH over the P-256 curve
<xref target="FIPS186"></xref>. The content body is shown here encoded in URL-safe base64 for presentation reasons only.</t>

<t>The receiver (in this case, the HTTP client) uses the key identified by the string “dhkey” and the
sender (the server) uses a key pair for which the public share is included in the “dh” parameter
above. The keys shown below use uncompressed points <xref target="X.692"></xref> encoded using URL-safe base64. Line
wrapping is added for presentation purposes only.</t>

<figure><artwork><![CDATA[
   Receiver:
      private key: QjGwenE3vCg8Eajo-PukGgUkYq8Vu-SQn04Cc9DR-YA
      public key: BBM3pYS4nXG6bQYnZbGDY7l6CVrQTZ-1u00h7XV6A_TD
                v7mXvv5k29uoLid8SdDycw341PJTW4hNCe2FNysN52U
   Sender:
      private key: wlC-qzKBWO6jYq32nlD0ZZVsI5jGVBC1gN7zkXjaPks
      public key: <the value of the "dh" parameter>
]]></artwork></figure>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="the-aesgcm-128-http-content-coding" title="The “aesgcm-128” HTTP content-coding">

<t>This memo registers the “encrypted” HTTP content-coding in the HTTP Content Codings Registry, as
detailed in <xref target="aesgcm128"/>.</t>

<t><list style="symbols">
  <t>Name: aesgcm-128</t>
  <t>Description: AES-GCM encryption with a 128-bit key</t>
  <t>Reference [this specification]</t>
</list></t>

</section>
<section anchor="encryption-header-fields" title="Encryption Header Fields">

<t>This memo registers the “Encryption” HTTP header field in the Permanent Message Header Registry, as
detailed in <xref target="encryption"/>.</t>

<t><list style="symbols">
  <t>Field name: Encryption</t>
  <t>Protocol: HTTP</t>
  <t>Status: Standard</t>
  <t>Reference: [this specification]</t>
  <t>Notes:</t>
</list></t>

<t>This memo registers the “Encryption-Key” HTTP header field in the Permanent Message Header Registry,
as detailed in <xref target="encryption-key"/>.</t>

<t><list style="symbols">
  <t>Field name: Encryption-Key</t>
  <t>Protocol: HTTP</t>
  <t>Status: Standard</t>
  <t>Reference: [this specification]</t>
  <t>Notes:</t>
</list></t>

</section>
<section anchor="encryption-registry" title="The HTTP Encryption Parameter Registry">

<t>This memo establishes a registry for parameters used by the “Encryption” header
field under the “Hypertext Transfer Protocol (HTTP) Parameters” grouping.  The
“Hypertext Transfer Protocol (HTTP) Encryption Parameters” operates under an
“Specification Required” policy <xref target="RFC5226"></xref>.</t>

<t>Entries in this registry are expected to include the following information:</t>

<t><list style="symbols">
  <t>Parameter Name: The name of the parameter.</t>
  <t>Purpose: A brief description of the purpose of the parameter.</t>
  <t>Reference: A reference to a specification that defines the semantics of the parameter.</t>
</list></t>

<t>The initial contents of this registry are:</t>

<section anchor="keyid" title="keyid">

<t><list style="symbols">
  <t>Parameter Name: keyid</t>
  <t>Purpose: Identify the key that is in use.</t>
  <t>Reference: [this document]</t>
</list></t>

</section>
<section anchor="salt" title="salt">

<t><list style="symbols">
  <t>Parameter Name: salt</t>
  <t>Purpose: Provide a source of entropy for derivation of the content encryption key. This value is mandatory.</t>
  <t>Reference: [this document]</t>
</list></t>

</section>
<section anchor="rs" title="rs">

<t><list style="symbols">
  <t>Parameter Name: rs</t>
  <t>Purpose: The size of the encrypted records.</t>
  <t>Reference: [this document]</t>
</list></t>

</section>
</section>
<section anchor="encryption-key-registry" title="The HTTP Encryption-Key Parameter Registry">

<t>This memo establishes a registry for parameters used by the “Encryption-Key” header
field under the “Hypertext Transfer Protocol (HTTP) Parameters” grouping.  The
“Hypertext Transfer Protocol (HTTP) Encryption Parameters” operates under an
“Specification Required” policy <xref target="RFC5226"></xref>.</t>

<t>Entries in this registry are expected to include the following information:</t>

<t><list style="symbols">
  <t>Parameter Name: The name of the parameter.</t>
  <t>Purpose: A brief description of the purpose of the parameter.</t>
  <t>Reference: A reference to a specification that defines the semantics of the parameter.</t>
</list></t>

<t>The initial contents of this registry are:</t>

<section anchor="keyid-1" title="keyid">

<t><list style="symbols">
  <t>Parameter Name: keyid</t>
  <t>Purpose: Identify the key that is in use.</t>
  <t>Reference: [this document]</t>
</list></t>

</section>
<section anchor="key" title="key">

<t><list style="symbols">
  <t>Parameter Name: key</t>
  <t>Purpose: Provide an explicit key.</t>
  <t>Reference: [this document]</t>
</list></t>

</section>
<section anchor="dh" title="dh">

<t><list style="symbols">
  <t>Parameter Name: dh</t>
  <t>Purpose: Carry a modp or elliptic curve Diffie-Hellman share used to derive a key.</t>
  <t>Reference: [this document]</t>
</list></t>

</section>
</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This mechanism assumes the presence of a key management framework that is used to manage the
distribution of keys between valid senders and receivers.  Defining key management is part of
composing this mechanism into a larger application, protocol, or framework.</t>

<t>Implementation of cryptography - and key management in particular - can be difficult.  For instance,
implementations need to account for the potential for exposing keying material on side channels,
such as might be exposed by the time it takes to perform a given operation.  The requirements for a
good implementation of cryptographic algorithms can change over time.</t>

<section anchor="key-and-nonce-reuse" title="Key and Nonce Reuse">

<t>Encrypting different plaintext with the same content encryption key and nonce in AES-GCM is not safe
<xref target="RFC5116"></xref>.  The scheme defined here relies on the uniqueness of the “nonce” parameter to ensure that
the content encryption key is different for every message.</t>

<t>If a key and nonce are reused, this could expose the content encryption key and it makes message
modification trivial.  If the same key is used for multiple messages, then the nonce parameter MUST
be unique for each.  An implementation SHOULD generate a random nonce parameter for every message,
though using a counter could achieve the desired result.</t>

</section>
<section anchor="content-integrity" title="Content Integrity">

<t>This mechanism only provides content origin authentication.  The authentication tag only ensures
that those with access to the content encryption key produce a message that will be accepted as
valid.</t>

<t>Any entity with the content encryption key can therefore produce content that will be accepted as
valid.  This includes all recipients of the same message.</t>

<t>Furthermore, any entity that is able to modify both the Encryption header field and the message
payload can replace messages.  Without the content encryption key however, modifications to or
replacement of parts of a message are not possible.</t>

</section>
<section anchor="leaking-information-in-headers" title="Leaking Information in Headers">

<t>Because “encrypted” only operates upon the message payload, any information exposed in headers is
visible to anyone who can read the message.</t>

<t>For example, the Content-Type header can leak information about the message payload.</t>

<t>There are a number of strategies available to mitigate this threat, depending upon the
application’s threat model and the users’ tolerance for leaked information:</t>

<t><list style="numbers">
  <t>Determine that it is not an issue. For example, if it is expected that all content stored will be
“application/json”, or another very common media type, exposing the Content-Type header could be an
acceptable risk.</t>
  <t>If it is considered sensitive information and it is possible to determine it through other means
(e.g., out of band, using hints in other representations, etc.), omit the relevant headers, and/or
normalize them. In the case of Content-Type, this could be accomplished by always sending
Content-Type: application/octet-stream (the most generic media type).</t>
  <t>If it is considered sensitive information and it is not possible to convey it elsewhere,
encapsulate the HTTP message using the application/http media type <xref target="RFC7230"></xref>, encrypting that as the
payload of the “outer” message.</t>
</list></t>

</section>
<section anchor="poisoning-storage" title="Poisoning Storage">

<t>This mechanism only offers encryption of content; it does not perform authentication or
authorization, which still needs to be performed (e.g., by HTTP authentication <xref target="RFC7235"></xref>).</t>

<t>This is especially relevant when a HTTP PUT request is accepted by a server; if the request is
unauthenticated, it becomes possible for a third party to deny service and/or poison the store.</t>

</section>
<section anchor="sizing-and-timing-attacks" title="Sizing and Timing Attacks">

<t>Applications using this mechanism need to be aware that the size of encrypted messages, as well as
their timing, HTTP methods, URIs and so on, may leak sensitive information.</t>

<t>This risk can be mitigated through the use of the padding that this mechanism provides.
Alternatively, splitting up content into segments and storing the separately might reduce
exposure. HTTP/2 <xref target="I-D.ietf-httpbis-http2"></xref> combined with TLS <xref target="RFC5246"></xref> might be used to hide the size
of individual messages.</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC4492'>

<front>
<title>Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'>
<organization /></author>
<author initials='N.' surname='Bolyard' fullname='N. Bolyard'>
<organization /></author>
<author initials='V.' surname='Gupta' fullname='V. Gupta'>
<organization /></author>
<author initials='C.' surname='Hawk' fullname='C. Hawk'>
<organization /></author>
<author initials='B.' surname='Moeller' fullname='B. Moeller'>
<organization /></author>
<date year='2006' month='May' />
<abstract>
<t>This document describes new key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol.  In particular, it specifies the use of Elliptic Curve Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of Elliptic Curve Digital Signature Algorithm (ECDSA) as a new authentication mechanism.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4492' />
<format type='TXT' octets='72231' target='http://www.rfc-editor.org/rfc/rfc4492.txt' />
</reference>



<reference anchor='RFC4648'>

<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
<organization /></author>
<date year='2006' month='October' />
<abstract>
<t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4648' />
<format type='TXT' octets='35491' target='http://www.rfc-editor.org/rfc/rfc4648.txt' />
</reference>



<reference anchor='RFC7230'>

<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract></front>

<seriesInfo name='RFC' value='7230' />
<format type='TXT' octets='205947' target='http://www.rfc-editor.org/rfc/rfc7230.txt' />
</reference>



<reference anchor='RFC7231'>

<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract></front>

<seriesInfo name='RFC' value='7231' />
<format type='TXT' octets='235053' target='http://www.rfc-editor.org/rfc/rfc7231.txt' />
</reference>



<reference anchor='RFC5116'>

<front>
<title>An Interface and Algorithms for Authenticated Encryption</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'>
<organization /></author>
<date year='2008' month='January' />
<abstract>
<t>This document defines algorithms for Authenticated Encryption with Associated Data (AEAD), and defines a uniform interface and a registry for such algorithms.  The interface and registry can be used as an application-independent set of cryptoalgorithm suites.  This approach provides advantages in efficiency and security, and promotes the reuse of crypto implementations. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5116' />
<format type='TXT' octets='50539' target='http://www.rfc-editor.org/rfc/rfc5116.txt' />
</reference>



<reference anchor='RFC5869'>

<front>
<title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
<author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'>
<organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'>
<organization /></author>
<date year='2010' month='May' />
<abstract>
<t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t></abstract></front>

<seriesInfo name='RFC' value='5869' />
<format type='TXT' octets='25854' target='http://www.rfc-editor.org/rfc/rfc5869.txt' />
</reference>


<reference anchor="FIPS180-2" >
  <front>
    <title>NIST FIPS 180-2, Secure Hash Standard</title>
    <author initials="National Institute of Standards and Technology, U.S." surname="Department of Commerce" fullname="NIST">
      <organization></organization>
    </author>
    <date year="2002" month="August"/>
  </front>
</reference>
<reference anchor="DH" >
  <front>
    <title>New Directions in Cryptography</title>
    <author initials="W." surname="Diffie">
      <organization></organization>
    </author>
    <author initials="M." surname="Hellman">
      <organization></organization>
    </author>
    <date year="1977" month="June"/>
  </front>
  <seriesInfo name="IEEE Transactions on Information Theory, V.IT-22 n.6" value=""/>
</reference>


    </references>

    <references title='Informative References'>





<reference anchor='RFC4880'>

<front>
<title>OpenPGP Message Format</title>
<author initials='J.' surname='Callas' fullname='J. Callas'>
<organization /></author>
<author initials='L.' surname='Donnerhacke' fullname='L. Donnerhacke'>
<organization /></author>
<author initials='H.' surname='Finney' fullname='H. Finney'>
<organization /></author>
<author initials='D.' surname='Shaw' fullname='D. Shaw'>
<organization /></author>
<author initials='R.' surname='Thayer' fullname='R. Thayer'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This document is maintained in order to publish all necessary information needed to develop interoperable applications based on the OpenPGP format. It is not a step-by-step cookbook for writing an application. It describes only the format and methods needed to read, check, generate, and write conforming packets crossing any network. It does not deal with storage and implementation questions. It does, however, discuss implementation issues necessary to avoid security flaws.&lt;/t>&lt;t> OpenPGP software uses a combination of strong public-key and symmetric cryptography to provide security services for electronic communications and data storage. These services include confidentiality, key management, authentication, and digital signatures. This document specifies the message formats used in OpenPGP. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4880' />
<format type='TXT' octets='203706' target='http://www.rfc-editor.org/rfc/rfc4880.txt' />
</reference>



<reference anchor='RFC5226'>

<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t>&lt;t> In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t>&lt;t> This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='5226' />
<format type='TXT' octets='66160' target='http://www.rfc-editor.org/rfc/rfc5226.txt' />
</reference>



<reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='http://www.rfc-editor.org/rfc/rfc5246.txt' />
</reference>



<reference anchor='RFC5652'>

<front>
<title>Cryptographic Message Syntax (CMS)</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2009' month='September' />
<abstract>
<t>This document describes the Cryptographic Message Syntax (CMS).  This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='STD' value='70' />
<seriesInfo name='RFC' value='5652' />
<format type='TXT' octets='126813' target='http://www.rfc-editor.org/rfc/rfc5652.txt' />
</reference>



<reference anchor='RFC7235'>

<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework.</t></abstract></front>

<seriesInfo name='RFC' value='7235' />
<format type='TXT' octets='38142' target='http://www.rfc-editor.org/rfc/rfc7235.txt' />
</reference>



<reference anchor='I-D.ietf-httpbis-http2'>
<front>
<title>Hypertext Transfer Protocol version 2</title>

<author initials='M' surname='Belshe' fullname='Mike Belshe'>
    <organization />
</author>

<author initials='R' surname='Peon' fullname='Roberto Peon'>
    <organization />
</author>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<date month='February' day='10' year='2015' />

<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.  This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-http2-17' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-http2-17.txt' />
</reference>


<reference anchor="FIPS186" >
  <front>
    <title>Digital Signature Standard (DSS)</title>
    <author >
      <organization>National Institute of Standards and Technology (NIST)</organization>
    </author>
    <date year="2013" month="July"/>
  </front>
  <seriesInfo name="NIST PUB 186-4" value=""/>
</reference>
<reference anchor="X.692" >
  <front>
    <title>Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>ANSI</organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="ANSI X9.62, 1998." value=""/>
</reference>




<reference anchor='I-D.ietf-jose-json-web-encryption'>
<front>
<title>JSON Web Encryption (JWE)</title>

<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>

<author initials='J' surname='Hildebrand' fullname='Joe Hildebrand'>
    <organization />
</author>

<date month='January' day='13' year='2015' />

<abstract><t>JSON Web Encryption (JWE) represents encrypted content using JavaScript Object Notation (JSON) based data structures. Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries defined by that specification. Related digital signature and MAC capabilities are described in the separate JSON Web Signature (JWS) specification.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-jose-json-web-encryption-40' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-jose-json-web-encryption-40.txt' />
</reference>


<reference anchor="XMLENC" target="http://www.w3.org/TR/xmlenc-core/">
  <front>
    <title>XML Encryption Syntax and Processing</title>
    <author initials="D." surname="Eastlake">
      <organization></organization>
    </author>
    <author initials="J." surname="Reagle">
      <organization></organization>
    </author>
    <author initials="T." surname="Imamura">
      <organization></organization>
    </author>
    <author initials="B." surname="Dillaway">
      <organization></organization>
    </author>
    <author initials="E." surname="Simon">
      <organization></organization>
    </author>
    <date year="2002" month="December"/>
  </front>
  <seriesInfo name="W3C REC" value=""/>
</reference>


    </references>


<section anchor="acknowledgements" title="Acknowledgements">

<t>The following people provided valuable feedback and suggestions: Richard Barnes,
Stephen Farrell, Eric Rescorla, and Jim Schaad.</t>

</section>


  </back>
</rfc>

