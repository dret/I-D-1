<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-00" category="std">

  <front>
    <title>Binary Structured HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="headers"/>, and specifies its use in HTTP/2 – specifically, as part of HPACK Literal Header Field Representations (<xref target="RFC7541"/>) – in <xref target="negotiate"/>.</t>

<t><xref target="backport"/> defines how to use Structured Headers for many existing headers when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="headers" title="Binary Structured Headers">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>The types permissable as the top-level of Structured Header field values – Dictionary, List, and Item – are defined in terms of a Binary Literal Representation (<xref target="binlit"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541"/>.</t>

<t>Binary representations of the remaining types are defined in <xref target="leaf"/>.</t>

<section anchor="binlit" title="The Binary Literal Representation">

<t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame"/>).</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   Type (4)    | PLength (4+)  |
+---+---------------------------+
| Payload Data (Length octets)  |
+-------------------------------+
]]></artwork></figure>

<t>A binary literal representation contains the following fields:</t>

<t><list style="symbols">
  <t>Type: Four bits indicating the type of the payload.</t>
  <t>PLength: The number of octets used to represent the payload, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 4-bit prefix.</t>
  <t>Payload Data: The payload, as per below.</t>
</list></t>

<t>The following payload types are defined:</t>

<section anchor="lists" title="Lists">

<t>List values (type=0x1) have a payload consisting of a stream of Binary Structured Types representing the members of the list. Members that are Items are represented as per <xref target="inner-item"/>; members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="dictionaries" title="Dictionaries">

<t>Dictionary values (type=0x2) have a payload consisting of a stream of members.</t>

<t>Each member is represented by a key length, followed by that many bytes of the member-name, followed by Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  member-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| member-value
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the member-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>member-name: KL octets of the member-name</t>
  <t>member-value: One or more Binary Structure Types</t>
</list></t>

<t>member-values that are Items are represented as per <xref target="inner-item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="items" title="Items">

<t>Item values (type=0x3) have a payload consisting of Binary Structured Types, as described in <xref target="inner-item"/>.</t>

</section>
<section anchor="literal" title="String Literals">

<t>String Literals (type=0x4) are the string value of a header field; they are used to carry header field values that are not Binary Structured Headers, and may not be Structured Headers at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541"/>, Section 5.2.</t>

<t>Their payload is the octets of the field value.</t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
</section>
<section anchor="leaf" title="Binary Structured Types">

<t>Every Binary Structured Type starts with a 5-bit type field that identifies the format of its payload:</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
      Type (5)      |  Payload...
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Some Binary Structured Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x1) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Members (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the members, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Members: L octets</t>
</list></t>

<t>Each member of the list will be represented as an Item (<xref target="inner-item"/>); if any member cannot, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>The inner list’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the inner list.</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x2) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Parameters (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Parameters: L octets</t>
</list></t>

<t>Each parameter is represented by key length, followed by that many bytes of the parameter-name, followed by a Binary Structured Type representing the parameter-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  parameter-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| parameter-value (VL octets)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>parameter-name: KL octets of the parameter-name</t>
  <t>parameter-value: A Binary Structured type representing a bare item (<xref target="inner-item"/>)</t>
</list></t>

<t>Parameter-values are bare items; that is, they MUST NOT have parameters themselves.</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>Parameters are always associated with the Binary Structured Type that immediately preceded them. If parameters are not explicitly allowed on the preceding type, or there is no preceding type, it is an error.</t>

<t>ISSUE: use Huffman coding for parameter-name? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="inner-item" title="Item Payload Types">

<t>Individual Structured Header Items can be represented using the Binary Payload Types defined below.</t>

<t>The item’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the item.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x3) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |  Integer (2+)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix</t>
</list></t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x4) have a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |   Integer (2+)
+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  FLength (8+)
+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  Fractional (8+)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix.</t>
  <t>Fractional: The fractional component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix.</t>
</list></t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x5) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  String (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the string, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>String: L octets.</t>
</list></t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x6) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Token (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Token: L octets.</t>
</list></t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Byte Sequence (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Byte Sequence: L octets.</t>
</list></t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0x8) has a payload of two bits:</t>

<figure><artwork><![CDATA[
  5   6   7
+---+---+---+
  B |   X   |
+---+---+---+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. X is padding.</t>

</section>
</section>
</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the Binary Structured Types defined in <xref target="headers"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit"/>.</t>

<t>Fields that are Structured Headers can have their values represented using the Binary Literal Representation corresponding to that header’s top-level type – List, Dictionary, or Item; their values will then be serialised as a stream of Binary Structured Types.</t>

<t>Additionally, any field (including those defined as Structured Headers) can be serialised as a String Literal (<xref target="literal"/>), which accommodates headers that are not defined as Structured Headers, not valid Structured Headers, or that the sending implementation does not wish to send as Binary Structured Types for some other reason.</t>

<t>Note that Field Names are always serialised as String Literals (<xref target="literal"/>).</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and String Literals (<xref target="literal"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as String Literals (<xref target="literal"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<t>ISSUE: using separate names assures that the different syntax doesn’t “leak” into normal headers, but it isn’t strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn’t understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>ISSUE: todo</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of String Literals (<xref target="literal"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='October' day='31' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-14' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-14.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
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
AA==

-->

</rfc>

