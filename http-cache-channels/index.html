<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "about:legacy-compat">
<html lang="en"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>HTTP Cache Channels</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Notational Conventions" href="#rfc.section.2"><link rel="Chapter" title="3 Cache Channels" href="#rfc.section.3"><link rel="Chapter" title="4 Manging Freshness with Cache Channels" href="#rfc.section.4"><link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5"><link rel="Chapter" href="#rfc.section.6" title="6 Normative References"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><link rel="Appendix" title="B Operational Considerations" href="#rfc.section.B"><link rel="Appendix" title="C Implementation Notes" href="#rfc.section.C"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Nottingham, M."><meta name="dct.identifier" content="urn:ietf:id:draft-nottingham-http-cache-channels-02"><meta name="dct.issued" scheme="ISO8601" content="2015-11-14"><meta name="dct.abstract" content="This specification defines &#34;cache channels&#34; to propagate out-of-band events from HTTP origin servers (or their delegates) to subscribing caches. It also defines an event payload that gives finer-grained control over cache freshness."><meta name="description" content="This specification defines &#34;cache channels&#34; to propagate out-of-band events from HTTP origin servers (or their delegates) to subscribing caches. It also defines an event payload that gives finer-grained control over cache freshness."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1">Introduction</a></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2">Notational Conventions</a></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3">Cache Channels</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">Channel Subscription</a></li><li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2">Event Application</a></li><li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3">Atom Cache Channels</a><ul><li><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3.1">The 'cc:precision' Feed Extension</a></li><li><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3.2">The 'cc:lifetime' Feed Extension</a></li><li><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3.3">Example</a></li></ul></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4">Manging Freshness with Cache Channels</a><ul><li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1">The 'channel-maxage' Response Cache-Control Extension</a></li><li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2">The 'stale' Cache Channel Event</a></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5">Security Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.A">Acknowledgements</a></li><li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.B">Operational Considerations</a></li><li><a href="#rfc.section.C">C.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.C">Implementation Notes</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Yahoo! Inc.</td></tr><tr><td class="text-left">Intended status: Informational</td><td class="text-right">November 14, 2015</td></tr><tr><td class="text-left">Expires: May 17, 2016</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>HTTP Cache Channels</h1><div class="filename">draft-nottingham-http-cache-channels-02</div></div><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><p>This specification defines "cache channels" to propagate out-of-band events from HTTP origin servers (or their delegates) to subscribing caches. It also defines an event payload that gives finer-grained control over cache freshness.</p></div><div id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on May 17, 2016.</p></div><div id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2015 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div><div><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;Introduction</h2><div id="rfc.section.1.p.1"><p>This specification defines "cache channels" that propagate out-of-band events from <a href="#RFC2616">HTTP</a> <cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite> origin servers (or their delegates) to subscribing caches. It also defines an event payload that gives finer-grained control over cache freshness.</p></div><div id="rfc.section.1.p.2"><p>Typically, a cache will discover channels of interest by examining Cache-Control response headers for the "channel" extension; when present, it indicates that the response is associated with that channel. Upon subscription, caches will receive all events in that channel.</p></div><div id="rfc.section.1.p.3"><p>To allow use of a variety of underlying protocols, the process of subscription and the means of propagating events in the channel are specific to the transport in use. This specification does define one such channel transport, using the <a href="#RFC4287">Atom Syndication Format</a> <cite title="The Atom Syndication Format">[4]</cite>.</p></div><div id="rfc.section.1.p.4"><p>Likewise, channels may be used to convey a variety of events from origin servers to caches. This specification defines one such payload, the 'stale' event, that affords finer-grained control over freshness than available in HTTP alone.</p></div><div id="rfc.section.1.p.5"><p>Together, cache channels and the stale event enable an origin server to maintain control over the content of a set of caches while increasing their efficiency. For example, "reverse proxies" are often used to accelerate HTTP servers by caching their content; cache channels and stale events can be used to more closely control their behaviour.</p></div><div id="rfc.section.1.p.6"><p>This use of cache channels is similar to an invalidation protocol, except that the protocol described here operates by extending cached responses' freshness lifetime, rather than invalidating them. This preserves the semantics of the HTTP caching model and assures that the failure modes are safe.</p></div><div id="rfc.section.1.p.7"><p>Additionally, the 'group' functionality of cache channels enables stale events to apply to several cached responses, thereby offering control over freshness of responses whose request-URIs may not be known. For example, a HTTP search interface may have given several responses containing the same information; if they are grouped together, it is possible to force them to become stale without knowing their request-URIs.</p></div></div><div><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;Notational Conventions</h2><div id="rfc.section.2.p.1"><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[1]</cite></a>, as scoped to those conformance targets.</p></div><div id="rfc.section.2.p.2"><p>This specification uses the augmented Backus-Naur Form of RFC2616 <a href="#RFC2616"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>, and includes the delta-seconds rule from that specification, and the absolute-URI rule from RFC3986 <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[3]</cite></a>.</p></div><div id="rfc.section.2.p.3"><p>Elements defined by this specification use the <a href="#W3C.REC-xml-names-19990114">XML namespace</a> <cite title="Namespaces in XML">[6]</cite> URI "http://purl.org/syndication/cache-channel". In this specification, that URI is assumed to be bound to the prefix "cc".</p></div></div><div><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;Cache Channels</h2><div id="rfc.section.3.p.1"><p>A cache channel is an out-of-band path from an origin server (or its delegate) to one or more interested caches. It is identified by a URI <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[3]</cite></a>.</p></div><div id="rfc.section.3.p.2"><p>A channel contains events, each of which may be associated with one or more URIs. The payload of each event is applied to its associated URIs when it is received.</p></div><div id="rfc.section.3.p.3"><p>Typically, a cache channel will convey events applicable to a variety of URIs in an administrative domain; for example, it might carry all events that apply to a single origin server, or a group of origin servers.</p></div><div id="rfc.section.3.p.4"><p>From the perspective of a cache, a channel has several interesting states;</p></div><div id="rfc.section.3.p.5"><ul><li>unsubscribed: The channel is not being monitored.</li><li>connected: The channel is being monitored, and events are able to be propagated.</li><li>disconnected: The channel is being monitored, but events are not able to be propagated.</li></ul></div><div id="rfc.section.3.p.6"><p>Channels MUST make the events that they contain available for an advertised amount of time, known as the lifetime of the channel. This allows clients that have been disconnected to re-synchronise themselves with the contents of the channel upon becoming re-connected.</p></div><div id="rfc.section.3.p.7"><p>Channels SHOULD also advertise the desired maximum propagation delay for events, known as their precision.</p></div><div id="rfc.section.3.p.8"><p>Two general processes facilitate the operation of cache channels; subscription and event application.</p></div><div><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;Channel Subscription</h3><div id="rfc.section.3.1.p.1"><p>Channels are advertised using the "channel" HTTP response cache-control extension.</p></div><div id="rfc.figure.u.1"><pre>
channel-extension = "channel" "=" &lt;"&gt; channel-URI &lt;"&gt;
      channel-URI = absolute-URI
</pre></div><div id="rfc.section.3.1.p.2"><p>A recipient of this cache-control extension can subscribe to the channel-URI when interested in receiving events associated with the response.</p></div><div id="rfc.section.3.1.p.3"><p>The specific mechanism for subscription is determined by the channel-URI's scheme and other factors (e.g., the media type of the representation obtained by dereferencing that URI).</p></div><div id="rfc.section.3.1.p.4"><p>If a subsequent response has a different channel-URI, or no channel-URI, and there are no other responses associated with the same channel-URI, a subscriber MAY unsubscribe from the channel.</p></div><div id="rfc.section.3.1.p.5"><p>A response MUST NOT have more than one channel-extension.</p></div><div id="rfc.section.3.1.p.6"><p>For example,</p></div><div id="rfc.figure.u.2"><pre>
  Cache-Control: max-age=300, channel="http://example.org/channels/a"
</pre></div></div><div><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;Event Application</h3><div id="rfc.section.3.2.p.1"><p>An event carries one or more event-URIs, which are used to determine what cached responses the event applies to. This includes responses whose request-URI matches an event-URI, and those with a group-URI matching an event-URI.</p></div><div id="rfc.section.3.2.p.2"><p>Responses can be associated with a group-URI using the "group" response Cache-Control extension;</p></div><div id="rfc.figure.u.3"><pre>
 group-extension = "group" "=" &lt;"&gt; group-URI &lt;"&gt;
       group-URI = absolute-URI
</pre></div><div id="rfc.section.3.2.p.3"><p>A response MAY have any number of group-extensions.</p></div><div id="rfc.section.3.2.p.4"><p>For example, a response carrying the following Cache-Control header;</p></div><div id="rfc.figure.u.4"><pre>
  Cache-Control: max=age=600, channel="http://example.com/channels/a",
                 group="urn:uuid:30A909D9-BC7A-4257-BE09-6F781AD6471F"
</pre></div><div id="rfc.section.3.2.p.5"><p>will not only have those events which match the response's request-URI applied, but also events who match the URI "urn:uuid:30A909D9-BC7A-4257-BE09-6F781AD6471F".</p></div><div id="rfc.section.3.2.p.6"><p>This mechanism allows application of events to arbitrary sets of responses using a synthetic identifier.</p></div><div id="rfc.section.3.2.p.7"><p>For example, if "http://example.com/", "http://example.com/top.html" and "http://example.com/index.html" are all associated with the group identified by "urn:uuid:30A909D9-BC7A-4257-BE09-6F781AD6471F", an event with that group-URI will be applied to all three.</p></div><div id="rfc.section.3.2.p.8"><p>By default, an event will apply to a matching response regardless of the headers used to select it (as indicated by the Vary response header). However, a particular event type can be specified to override this behaviour.</p></div><div id="rfc.section.3.2.p.9"><p>Note that an event MUST NOT be applied to responses whose channel-extension does not indicate that the response is associated with the channel that the event occurred in.</p></div></div><div><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;Atom Cache Channels</h3><div id="rfc.section.3.3.p.1"><p>The <a href="#RFC4287">Atom Syndication Format</a> <cite title="The Atom Syndication Format">[4]</cite> -- when used with channel-specific extensions in a specific pattern over HTTP -- is one suitable cache channel transport.</p></div><div id="rfc.section.3.3.p.2"><p>A channel is subscribed to by commencing regular polling of the channel-URI. Polling MUST be attempted at least as often as the channel's precision, as indicted by the cc:precision feed extension.</p></div><div id="rfc.section.3.3.p.3"><p>The feed's 'current' link relation value MUST contain the channel-URI, which MUST be a HTTP URI.</p></div><div id="rfc.section.3.3.p.4"><p>The channel is considered disconnected when the last successful poll occurred more than channel-precision seconds ago, or a successful poll has not yet occurred. A successful poll is defined as one that results in a fresh (according to the HTTP caching model) copy of a well-formed, valid feed document with a 'self' link relation whose value is character-for-character identical to the channel-URI.</p></div><div id="rfc.section.3.3.p.5"><p>The feed SHOULD be <a href="#RFC5005">archived</a> <cite title="Feed Paging and Archiving">[5]</cite> to allow the full state of the channel to be reconstructed, while minimising the amount of bandwidth that polling the channel consumes. If a feed is archived, the channel is only considered connected when the entire contents of the logical feed.</p></div><div id="rfc.section.3.3.p.6"><p>The cc:lifetime feed extension indicates the minimum span of time that events are available in the logical feed for.</p></div><div id="rfc.section.3.3.p.7"><p>Entries in the feed represent events, in reverse-chronological order. The atom:link element(s) with the "alternate" relation determines the URI(s) that an event is applicable to.</p></div><div><h4 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;The 'cc:precision' Feed Extension</h4><div id="rfc.section.3.3.1.p.1"><p>An Atom cache channel's precision is indicated by the cc:precision element. This is an feed-level extension element whose content indicates the precision in seconds.</p></div><div id="rfc.section.3.3.1.p.2"><p>For example;</p></div><div id="rfc.figure.u.5"><pre>
  &lt;cc:precision&gt;60&lt;/cc:precision&gt;
</pre></div><div id="rfc.section.3.3.1.p.3"><p>indicates that the precision of the channel it occurs in is one minute.</p></div></div><div><h4 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;The 'cc:lifetime' Feed Extension</h4><div id="rfc.section.3.3.2.p.1"><p>An Atom cache channel's lifetime is indicated by the cc:lifetime element. This is an feed-level extension element whose content indicates the lifetime in seconds.</p></div><div id="rfc.section.3.3.2.p.2"><p>For example;</p></div><div id="rfc.figure.u.6"><pre>
  &lt;cc:lifetime&gt;2592000&lt;/cc:lifetime&gt;
</pre></div><div id="rfc.section.3.3.2.p.3"><p>indicates that the lifetime of the channel it occurs in is 30 days.</p></div></div><div><h4 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;Example</h4><div id="rfc.figure.u.7"><pre>
&lt;feed xmlns="http://www.w3.org/2005/Atom"
 xmlns:cc="http://purl.org/syndication/cache-channel"&gt;
  &lt;title&gt;Invalidations for www.example.org&lt;/title&gt;
  &lt;id&gt;http://admin.example.org/events/&lt;/id&gt;
  &lt;link rel="self" 
   href="http://admin.example.org/events/current"/&gt;
  &lt;link rel="prev-archive" 
   href="http://admin.example.org/events/archive/1234"/&gt;
  &lt;updated&gt;2007-04-13T11:23:42Z&lt;/updated&gt;
  &lt;author&gt;
     &lt;name&gt;Administrator&lt;/name&gt;
     &lt;email&gt;web-admin@example.org&lt;/email&gt;
  &lt;/author&gt;
  &lt;cc:precision&gt;60&lt;/cc:precision&gt;
  &lt;cc:lifetime&gt;2592000&lt;/cc:lifetime&gt;
  &lt;entry&gt;
    &lt;title&gt;stale&lt;/title&gt;
    &lt;id&gt;http://admin.example.org/events/1124&lt;/id&gt;
    &lt;updated&gt;2007-04-13T11:23:42Z&lt;/updated&gt;
    &lt;link href="urn:uuid:50D3565C-97A8-40E1-A5C8-CFA070166FEF"/&gt;
    &lt;cc:stale/&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;title&gt;stale&lt;/title&gt;
    &lt;id&gt;http://admin.example.org/events/1125&lt;/id&gt;
    &lt;updated&gt;2007-04-13T10:31:01Z&lt;/updated&gt;
    &lt;link href="http://www.example.org/img/123.gif" type="image/gif"/&gt;
    &lt;link href="http://www.example.org/img/123.png" type="image/png"/&gt;
    &lt;cc:stale/&gt;
  &lt;/entry&gt;
&lt;/feed&gt;
</pre></div><div id="rfc.section.3.3.3.p.1"><p>This feed document contains two events, the most recent applying to the URI "urn:uuid:50D3565C-97A8-40E1-A5C8-CFA070166FEF" and the other to "http://www.example.org/img/123.gif" and "http://www.example.org/img/123.png". The previous archive document is located at "http://admin.example.org/events/archive/1234", to allow the client to reconstruct missed events if necessary. The channel it represents has a precision of 60 seconds (thereby telling clients that they need to poll at least that often), and a lifetime of 30 days.</p></div></div></div></div><div><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;Manging Freshness with Cache Channels</h2><div id="rfc.section.4.p.1"><p>One use of cache channels is the management of cached responses' freshness lifetime. This is achieved through use of the 'channel-maxage' response Cache-Control extension, which allows subscribed caches to extend the freshness of a response until an applicable 'stale' cache channel event is received.</p></div><div><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;The 'channel-maxage' Response Cache-Control Extension</h3><div id="rfc.section.4.1.p.1"><p>The channel-maxage response cache-control extension allows controlled extension of the freshness lifetime of a cached response.</p></div><div id="rfc.figure.u.8"><pre>
  channel-maxage = "channel-maxage" [ "=" delta-seconds ]
</pre></div><div id="rfc.section.4.1.p.2"><p>A response containing this extension MAY be considered fresh when all of the following conditions are true;</p></div><div id="rfc.section.4.1.p.3"><ul><li>The cache is connected to the channel indicated by the channel-URI.</li><li>The channel does not contain a 'stale' event applicable to the cached response.</li><li>The response's current_age (as per HTTP <a href="#RFC2616"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>, Section 13.2.3) is no more than delta-seconds, if specified.</li></ul></div><div id="rfc.section.4.1.p.4"><p>For example a response with this Cache-Control header;</p></div><div id="rfc.figure.u.9"><pre>
  Cache-Control: channel="http://admin.example.org/events/current",
    channel-maxage=86400, max-age=30
</pre></div><div id="rfc.section.4.1.p.5"><p>will be considered fresh for 30 seconds by a cache that is not subscribed to the channel "http://admin.example.org/events/current", but can be considered fresh for up to a day by one that is, as long as the channel is connected and does not contain an applicable 'stale' event.</p></div><div id="rfc.section.4.1.p.6"><p>Or, if the response contains;</p></div><div id="rfc.figure.u.10"><pre>
  Cache-Control: channel="http://admin.example.org/events/current",
    channel-maxage, max-age=30
</pre></div><div id="rfc.section.4.1.p.7"><p>then it will be considered fresh for up to the channels' lifetime, provided that the channel is connected and does not contain a 'stale' event.</p></div></div><div><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;The 'stale' Cache Channel Event</h3><div id="rfc.section.4.2.p.1"><p>Cache channels can indicate that all cached responses associated with a URI are to be considered stale with the 'stale' event. In Atom channels, this event is indicated by the cc:stale entry-level extension;</p></div><div id="rfc.figure.u.11"><pre>
  &lt;cc:stale/&gt;
</pre></div><div id="rfc.section.4.2.p.2"><p>When received, this event indicates that any cached response associated with the event's URI(s) MUST be considered stale (for purposes of extension by channel-maxage) within channel-precision seconds.</p></div></div></div><div><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;Security Considerations</h2><div id="rfc.section.5.p.1"><p>Subscribing to a cache channel may incur more traffic than would otherwise be generated by typical operation of a cache. Attackers might use this to cause an implementation to subscribe to many channels, reducing their capacity or even denying service. As a result, caches that implement this protocol should have some mechanism of limiting or controlling the channels that will be subscribed to.</p></div><div id="rfc.section.5.p.2"><p>The information in a cache channel may be considered sensitive by its publisher; in this case, they should require credentials to be presented by subscribers.</p></div></div><h2 id="rfc.references"><a href="#rfc.section.6" id="rfc.section.6">6.</a> Normative References</h2><dl class="reference"><dt id="RFC2119">[1]</dt><dd>Bradner, S., “<a href="http://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC2616">[2]</dt><dd>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “<a href="http://www.rfc-editor.org/info/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>”, RFC&nbsp;2616, <a href="http://dx.doi.org/10.17487/RFC2616">DOI&nbsp;10.17487/RFC2616</a>, June&nbsp;1999, &lt;<a href="http://www.rfc-editor.org/info/rfc2616">http://www.rfc-editor.org/info/rfc2616</a>&gt;.</dd><dt id="RFC3986">[3]</dt><dd>Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="http://www.rfc-editor.org/info/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, <a href="http://dx.doi.org/10.17487/RFC3986">DOI&nbsp;10.17487/RFC3986</a>, January&nbsp;2005, &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.</dd><dt id="RFC4287">[4]</dt><dd>Nottingham, M., Ed. and R. Sayre, Ed., “<a href="http://www.rfc-editor.org/info/rfc4287">The Atom Syndication Format</a>”, RFC&nbsp;4287, <a href="http://dx.doi.org/10.17487/RFC4287">DOI&nbsp;10.17487/RFC4287</a>, December&nbsp;2005, &lt;<a href="http://www.rfc-editor.org/info/rfc4287">http://www.rfc-editor.org/info/rfc4287</a>&gt;.</dd><dt id="RFC5005">[5]</dt><dd>Nottingham, M., “<a href="http://www.rfc-editor.org/info/rfc5005">Feed Paging and Archiving</a>”, RFC&nbsp;5005, <a href="http://dx.doi.org/10.17487/RFC5005">DOI&nbsp;10.17487/RFC5005</a>, September&nbsp;2007, &lt;<a href="http://www.rfc-editor.org/info/rfc5005">http://www.rfc-editor.org/info/rfc5005</a>&gt;.</dd><dt id="W3C.REC-xml-names-19990114">[6]</dt><dd>Bray, T., Hollander, D., and A. Layman, “<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114">Namespaces in XML</a>”, World Wide Web Consortium Recommendation&nbsp;REC-xml-names-19990114, January&nbsp;1999, &lt;<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114">http://www.w3.org/TR/1999/REC-xml-names-19990114</a>&gt;.</dd></dl><div><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;Acknowledgements</h2><div id="rfc.section.A.p.1"><p>Henrik Nordstrom has given invaluable advice and feedback on the design of this specification. Thanks also to Jeff McCarrell, John Nienart, Evan Torrie, and Chris Westin for their suggestions. The author takes all responsibility for errors and omissions.</p></div></div><div><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a>&nbsp;Operational Considerations</h2><div id="rfc.section.B.p.1"><p>There are a number of aspects to considered when using cache channels;</p></div><div id="rfc.section.B.p.2"><ul><li>They are most efficient when a small number of channels (ideally, one) is used to convey events about a large number of associated resources (e.g., an entire Web site, or a number of related sites).</li><li>In particular, when using Atom channels care should be taken to assure that the additional requests necessary to poll the channel are offset by the load reduction achieved. In doing so, the anticipated number of clients, channel-precision, change rate for cached responses and number of responses being monitored by the channel need to be considered.</li><li>Feed documents from Atom-based channels should be cacheable, to allow clusters of caches and cache hierarchies to share them more efficiently.</li><li>When using channels to update freshness information, it is critical to assure that any new content is actually available before events are propagated; if the event is too early and stale cached content forces revalidation, it is possible that the updated content will not be loaded into cache.</li><li>Responses that use the channel-maxage mechanism should also specify a max-age, both to allow channel-naive caches to store them in a limited fashion, and also to allow some types of channel implementations to initially store the response before subscribing.</li></ul></div></div><div><h2 id="rfc.section.C"><a href="#rfc.section.C">C.</a>&nbsp;Implementation Notes</h2><div id="rfc.section.C.p.1"><p>Handling of the 'stale' event in order to extend freshness can often be effected in an existing cache implementation with only small changes.</p></div><div id="rfc.section.C.p.2"><p>In particular, most caches can be easily modified to call a function (whether in-process or in a separate process) when a stale response is found, before the decision to validate it on the origin server is made. Using the request-URI, the stored Cache-Control response header and the age of the cached response as input, such a function should return either STALE, which indicates that the cached response is in fact stale, or FRESH, along with an indication of how much the freshness lifetime should be extended by.</p></div><div id="rfc.section.C.p.3"><p>This function determines its response based upon its application of the following rules to the state that is collected about the channel in question;</p></div><div id="rfc.section.C.p.4"><ul><li>If there is no channel-maxage directive in the Cache-Control response header, STALE can be returned immediately.</li><li>If the channel-URI is missing from the Cache-Control response header, the response is assumed to not be associated with any channel, and a STALE can immediately be returned.</li><li>If the channel is unsubscribed, it should be scheduled for subscription, and STALE returned.</li><li>If the channel is disconnected, return STALE.</li><li>If there is a 'stale' event in the channel that applies to the request-URI or group-URI (if present), and cached response's age is greater than the age of the of that event, return STALE.</li><li>If the cached response's age is greater than channel-maxage, return STALE.</li><li>If the cached response's age is greater than the channel's lifetime, return STALE.</li><li>Otherwise, return FRESH freshness=[channel-precision].</li></ul></div></div><div class="avoidbreakinside"><h2 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h2><p><b>Mark Nottingham</b><br>Yahoo! Inc.<br>EMail: <a href="mailto:mnot@yahoo-inc.com">mnot@yahoo-inc.com</a><br>URI: <a href="http://www.mnot.net/">http://www.mnot.net/</a></p></div></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>